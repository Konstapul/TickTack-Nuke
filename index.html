<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect 5: War Room</title>
    <style>
        :root {
            --bg-color: #050a10;
            --panel-bg: rgba(10, 20, 30, 0.95);
            --grid-color: #1a3c5a;
            --text-main: #64d2ff;  /* Cyan */
            --text-sec: #ffaa00;   /* Amber */
            --text-alert: #ff3333; /* Red */
            --text-boost: #d946ef; /* Magenta */
            
            --p1-color: #00f0ff;   /* Neon Cyan */
            --p2-color: #ffaa00;   /* Neon Amber */
            
            --scored-p1: #00f0ff;  
            --scored-p2: #ffaa00;  
            
            --crater-bg: #000000;
            --border-style: 1px solid #1a3c5a;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--bg-color);
            background-image: 
                linear-gradient(rgba(5, 10, 16, 0.95), rgba(5, 10, 16, 0.95)),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.5) 3px);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            overflow-x: hidden;
            user-select: none;
        }

        /* Wrapper for scaling */
        .app-root {
            transition: transform 0.2s ease;
            transform-origin: top center;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        h1 {
            margin-bottom: 5px;
            font-size: 1.8rem;
            text-shadow: 0 0 5px var(--text-main);
            border-bottom: 2px solid var(--text-main);
            padding-bottom: 10px;
            width: 100%;
            max-width: 1000px;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .sim-header-right { font-size: 0.7rem; opacity: 0.7; }

        /* --- Main Game Layout --- */
        .game-wrapper {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
        }

        /* --- Side Panels --- */
        .side-panel {
            width: 200px;
            background: rgba(10, 20, 30, 0.6);
            border: 1px solid #334;
            padding: 15px;
            font-size: 0.7rem;
            color: #889;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .side-panel h3 {
            color: var(--text-main);
            border-bottom: 1px solid #334;
            margin: 0 0 8px 0;
            padding-bottom: 4px;
            font-size: 0.8rem;
        }

        .tut-item { 
            margin-bottom: 15px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .tut-label { color: #fff; font-weight: bold; display: block; margin-bottom: 6px; font-size: 0.75rem; }
        .tut-desc { line-height: 1.3; margin-top: 6px; color: #aaa; }

        /* Pattern Mini-Grids */
        .mini-grid {
            display: grid;
            gap: 2px;
            background: rgba(0,0,0,0.5);
            padding: 4px;
            border: 1px solid #334;
        }
        .mini-cell {
            width: 10px;
            height: 10px;
            background: #1a2a3a;
            border-radius: 50%;
        }
        .mini-cell.active {
            background: var(--text-main);
            box-shadow: 0 0 5px var(--text-main);
        }
        .grid-5row { grid-template-columns: repeat(5, 1fr); }
        .grid-2x2 { grid-template-columns: repeat(2, 1fr); }
        .grid-plus { grid-template-columns: repeat(3, 1fr); }

        @media (max-width: 1000px) {
            .side-panel { display: none; }
        }

        /* --- Center Column --- */
        .game-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
        }

        .scoreboard {
            display: flex;
            gap: 15px;
            margin-bottom: 1rem;
            width: 100%;
        }

        .player-score {
            background: var(--panel-bg);
            border: var(--border-style);
            padding: 12px;
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            transition: all 0.3s;
        }

        .player-score.active-turn {
            border-color: currentColor;
            box-shadow: 0 0 20px rgba(255,255,255, 0.05);
        }
        
        .p1-panel { color: var(--p1-color); }
        .p2-panel { color: var(--p2-color); }

        .score-val {
            font-size: 2.5rem;
            font-weight: bold;
            line-height: 1;
            margin: 5px 0 10px 0;
            text-shadow: 0 0 10px currentColor;
        }

        .player-label { font-size: 0.75rem; font-weight: bold; margin-bottom: 5px; }

        /* Compact Resources */
        .resources-row {
            display: flex;
            gap: 5px;
            width: 100%;
            justify-content: center;
        }

        .res-item {
            font-size: 0.7rem;
            border: 1px solid currentColor;
            background: rgba(0,0,0,0.3);
            text-align: center;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 4px 2px;
        }
        .res-val { font-size: 1rem; font-weight: bold; line-height: 1; }
        .res-icon { font-size: 0.9rem; margin-bottom: 2px; display: block; }

        /* --- Status Bar --- */
        .status-bar {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 0.85rem;
            font-weight: bold;
            min-height: 1.2em;
        }
        .status-text { animation: blink-slow 2s infinite; }
        .status-bonus { color: var(--text-boost); animation: blink-fast 0.5s infinite alternate; }
        
        .isolation-indicator {
            font-size: 0.7rem;
            padding: 2px 6px;
            border: 1px solid #333;
            color: #555;
            transition: all 0.3s;
        }
        .isolation-indicator.available {
            border-color: var(--text-main);
            color: var(--text-main);
            box-shadow: 0 0 5px rgba(100, 210, 255, 0.2);
        }
        
        @keyframes blink-slow { 50% { opacity: 0.6; } }
        @keyframes blink-fast { from { opacity: 1; text-shadow: 0 0 10px currentColor; } to { opacity: 0.5; } }

        /* --- Board --- */
        .board-container {
            position: relative;
            padding: 4px;
            border: 1px solid var(--grid-color);
            background: rgba(0,0,0,0.5);
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        
        .board-container.impact { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-2px, 0, 0); } 20%, 80% { transform: translate3d(4px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-6px, 0, 0); } 40%, 60% { transform: translate3d(6px, 0, 0); } }

        .board {
            display: grid;
            width: min(90vw, 550px);
            height: min(90vw, 550px);
            background: transparent;
            border-top: 1px solid var(--grid-color);
            border-left: 1px solid var(--grid-color);
            cursor: crosshair;
            transition: opacity 0.5s;
        }
        
        .cell {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid var(--grid-color);
            border-bottom: 1px solid var(--grid-color);
            box-sizing: border-box; 
            overflow: hidden; 
        }
        
        .cell.crater {
            background: repeating-linear-gradient(
                45deg,
                #550000,
                #550000 5px,
                #000000 5px,
                #000000 10px
            );
            border: 1px solid #ff0000;
            box-shadow: inset 0 0 10px #ff0000;
        }

        .board.targeting .cell:hover { background: rgba(0, 255, 255, 0.1); box-shadow: inset 0 0 10px cyan; }
        .board.targeting .cell.invalid-target:hover { background: rgba(255, 0, 0, 0.2); box-shadow: inset 0 0 10px red; cursor: not-allowed; }
        
        .board.targeting-boosted .cell:hover { 
            background: rgba(217, 70, 239, 0.2); 
            box-shadow: inset 0 0 15px var(--text-boost); 
        }

        .piece {
            width: 60%; height: 60%; border-radius: 50%;
            transition: all 0.2s; 
            box-sizing: border-box;
            box-shadow: 0 0 8px currentColor;
        }
        .piece.p1 { background-color: var(--p1-color); color: var(--p1-color); }
        .piece.p2 { background-color: var(--p2-color); color: var(--p2-color); }
        
        .piece.placed { animation: ping 0.4s ease-out; }
        @keyframes ping { 0% { box-shadow: 0 0 0 0 currentColor; } 100% { box-shadow: 0 0 0 15px transparent; } }

        .piece.last-move {
            box-shadow: 0 0 0 2px #fff, 0 0 15px #fff !important;
            z-index: 10;
        }

        .piece.scored { 
            background-color: transparent !important;
            box-shadow: 0 0 0 3px currentColor, 0 0 15px currentColor;
            width: 65%; height: 65%; 
        }
        .piece.p1.scored { color: var(--scored-p1); }
        .piece.p2.scored { color: var(--scored-p2); }

        .piece.square-flash {
            animation: flash-square 0.5s ease-out;
        }
        @keyframes flash-square {
            0% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.3); filter: brightness(2); box-shadow: 0 0 20px #fff; }
            100% { transform: scale(1); filter: brightness(1); }
        }

        .piece.bunker {
            border-radius: 10%; 
            width: 75%; height: 75%;
            background: repeating-linear-gradient(45deg, currentColor, currentColor 2px, transparent 2px, transparent 4px);
            box-shadow: 0 0 0 2px currentColor, 0 0 10px currentColor;
            z-index: 5;
        }
        
        .piece.bunker.scored {
            background: transparent !important;
            box-shadow: inset 0 0 0 3px currentColor, 0 0 10px currentColor;
        }
        
        .piece.bunker.forming {
            animation: bunker-lock 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes bunker-lock {
            0% { transform: scale(1.2); opacity: 0.5; }
            50% { transform: scale(0.8); }
            100% { transform: scale(1); opacity: 1; }
        }

        .controls-area {
            width: 100%; margin-top: 15px;
            display: grid; grid-template-columns: 2fr 1fr; gap: 15px;
        }
        
        .panel { padding: 10px; border: 1px solid #333; background: rgba(0,0,0,0.5); }
        .panel h3 { margin: 0 0 10px 0; font-size: 0.7rem; color: #888; border-bottom: 1px solid #333; letter-spacing: 2px; }

        .btn-group { display: flex; gap: 8px; flex-wrap: wrap; }

        button {
            background: transparent; color: #888; border: 1px solid #444;
            padding: 8px 12px; font-family: inherit; font-size: 0.7rem; font-weight: bold;
            cursor: pointer; transition: all 0.2s; flex: 1; min-width: 80px;
        }
        button:hover:not(:disabled) { border-color: #fff; color: #fff; background: rgba(255,255,255,0.1); }
        button:disabled { opacity: 0.3; cursor: not-allowed; }

        .btn-nuke { color: var(--text-alert); border-color: var(--text-alert); }
        .btn-nuke:hover:not(:disabled) { background: rgba(255, 0, 0, 0.1); box-shadow: 0 0 10px rgba(255,0,0,0.4); }
        .btn-nuke.active { background: var(--text-alert); color: #000; }

        .btn-boost { color: var(--text-boost); border-color: var(--text-boost); }
        .btn-boost:hover:not(:disabled) { background: rgba(217, 70, 239, 0.1); box-shadow: 0 0 10px rgba(217, 70, 239, 0.4); }
        .btn-boost.active { background: var(--text-boost); color: #000; box-shadow: 0 0 15px var(--text-boost); animation: pulse-btn 1s infinite; }

        @keyframes pulse-btn { 0% { opacity: 1; } 50% { opacity: 0.8; transform: scale(0.98); } 100% { opacity: 1; } }

        .btn-system { border-color: #1a3c5a; }

        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); z-index: 100;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.5s;
        }
        .overlay.visible { opacity: 1; pointer-events: auto; }
        .modal { border: 2px solid var(--text-main); padding: 40px; text-align: center; background: #050a10; min-width: 300px;}
        .modal h2 { margin-top: 0; margin-bottom: 20px; font-size: 1.5rem; color: var(--text-main); }
        .modal-btn-group { display: flex; flex-direction: column; gap: 15px; }
        .btn-view-board { border-color: #666; color: #aaa; }
        
        .setting-row { margin-bottom: 20px; text-align: left; }
        .setting-label { display: block; margin-bottom: 10px; font-size: 0.8rem; color: #aaa; }
        .range-wrap { display: flex; align-items: center; gap: 10px; color: #aaa; font-size: 0.8rem; }
        input[type=range] { flex: 1; }

        .toast {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(10, 20, 30, 0.95); border: 1px solid var(--text-main);
            color: var(--text-main); padding: 10px 20px; font-size: 0.8rem;
            opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 200;
        }
        .toast.show { opacity: 1; }
    </style>
</head>
<body>

<div class="app-root" id="app-root">

    <h1>
        <span>WAR ROOM // SYMMETRIC</span>
        <span class="sim-header-right">V.5.2 [INFINITE_BONUS_FIX]</span>
    </h1>

    <div class="game-wrapper">
        
        <div class="side-panel tutorial-panel">
            <h3>PATTERNS</h3>
            <div class="tut-item">
                <span class="tut-label">5-IN-ROW</span>
                <div class="mini-grid grid-5row">
                    <div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell active"></div>
                </div>
                <div class="tut-desc">Win a Point + Earn Nuke.</div>
            </div>
            <div class="tut-item">
                <span class="tut-label">2x2 SQUARE</span>
                <div class="mini-grid grid-2x2">
                    <div class="mini-cell active"></div><div class="mini-cell active"></div>
                    <div class="mini-cell active"></div><div class="mini-cell active"></div>
                </div>
                <div class="tut-desc">Bonus Turn (Must be isolated).</div>
            </div>
            <div class="tut-item">
                <span class="tut-label">PLUS (+)</span>
                <div class="mini-grid grid-plus">
                    <div class="mini-cell"></div><div class="mini-cell active"></div><div class="mini-cell"></div>
                    <div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell active"></div>
                    <div class="mini-cell"></div><div class="mini-cell active"></div><div class="mini-cell"></div>
                </div>
                <div class="tut-desc">Creates 5 Bunkers + Earn Booster.</div>
            </div>
        </div>

        <div class="game-center">
            <div class="scoreboard">
                <div class="player-score p1-panel" id="p1-panel">
                    <div class="player-label">COM-A (CYAN)</div>
                    <div class="score-val" id="score1">0</div>
                    <div class="resources-row">
                        <div class="res-item"><span class="res-icon">☢</span><span class="res-val" id="nuke1">0</span></div>
                        <div class="res-item"><span class="res-icon">⚡</span><span class="res-val" id="boost1">0</span></div>
                        <div class="res-item"><span class="res-icon">⛨</span><span class="res-val" id="bunker1">0</span></div>
                    </div>
                </div>
                
                <div class="player-score p2-panel" id="p2-panel">
                    <div class="player-label">COM-B (AMBER)</div>
                    <div class="score-val" id="score2">0</div>
                    <div class="resources-row">
                        <div class="res-item"><span class="res-icon">☢</span><span class="res-val" id="nuke2">0</span></div>
                        <div class="res-item"><span class="res-icon">⚡</span><span class="res-val" id="boost2">0</span></div>
                        <div class="res-item"><span class="res-icon">⛨</span><span class="res-val" id="bunker2">0</span></div>
                    </div>
                </div>
            </div>

            <div class="status-bar">
                <div id="status-text" class="status-text">INITIALIZING SIMULATION...</div>
                <div id="iso-indicator" class="isolation-indicator">ISOLATION: CHECKING</div>
            </div>

            <div class="board-container">
                <div class="board" id="board"></div>
            </div>

            <div class="controls-area">
                <div class="panel">
                    <h3>ARSENAL</h3>
                    <div class="btn-group">
                        <button id="btn-nuke" class="btn-nuke" onclick="game.toggleTargeting()">LAUNCH ICBM</button>
                        <button id="btn-boost" class="btn-boost" onclick="game.toggleBoost()">ENGAGE BOOSTER</button>
                    </div>
                </div>
                <div class="panel">
                    <h3>SYSTEM</h3>
                    <div class="btn-group">
                        <button class="btn-system" onclick="game.openSettings()">SETTINGS</button>
                        <button class="btn-system" onclick="game.saveGame()">SAVE</button>
                        <button class="btn-system" onclick="game.loadGame()">LOAD</button>
                        <button class="btn-system" onclick="game.resetRound()">RESET</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="side-panel tutorial-panel">
            <h3>ORDNANCE</h3>
            <div class="tut-item">
                <span class="tut-label">STANDARD NUKE</span>
                <div class="tut-desc">Radius 1 (Cross).<br>Target: YOUR UNITS ONLY.<br>Blocked by Bunkers.</div>
            </div>
            <div class="tut-item">
                <span class="tut-label">BOOSTED NUKE</span>
                <div class="tut-desc">Radius 2 (Diamond).<br>Target: ANYWHERE.<br>Destroys Bunkers.</div>
            </div>
            <h3>STRUCTURES</h3>
            <div class="tut-item">
                <span class="tut-label">BUNKERS</span>
                <div class="tut-desc">Immune to Standard Nukes.<br>Created by (+) Pattern.</div>
            </div>
        </div>

    </div>

</div>

    <div class="overlay" id="overlay">
        <div class="modal">
            <h2 id="winner-title">VICTORY</h2>
            <div class="modal-btn-group">
                <button class="btn-system" onclick="game.resetRound()">RESTART SIMULATION</button>
                <button class="btn-view-board" onclick="game.hideOverlay()">VIEW BOARD STATE</button>
            </div>
        </div>
    </div>

    <div class="overlay" id="settings-overlay">
        <div class="modal">
            <h2>SYSTEM SETTINGS</h2>
            
            <div class="setting-row">
                <span class="setting-label">MAP SIZE (RESETS GAME)</span>
                <div class="btn-group">
                    <button onclick="game.setMapSize(13)">13x13 (SKIRMISH)</button>
                    <button onclick="game.setMapSize(15)">15x15 (STANDARD)</button>
                    <button onclick="game.setMapSize(19)">19x19 (GLOBAL)</button>
                </div>
            </div>

            <div class="setting-row">
                <span class="setting-label">UI SCALE</span>
                <div class="range-wrap">
                    <span>70%</span>
                    <input type="range" min="0.7" max="1.3" step="0.1" value="1" oninput="game.setScale(this.value)">
                    <span>130%</span>
                </div>
            </div>

            <button class="btn-system" onclick="document.getElementById('settings-overlay').classList.remove('visible')">CLOSE</button>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>

<script>
/**
 * CONNECT 5: WAR ROOM v5.2
 * Fix: Infinite Bonus Turn bug.
 * Patterns trigger simultaneously, and bonus turns are properly consumed.
 */

class SoundSystem {
    constructor() { this.ctx = null; }
    init() {
        if (!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }
    playTone(freq, type, duration, vol=0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }
    playNoise(duration, vol=0.2) {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    }
    playPlace() { this.playTone(600, 'sine', 0.1, 0.1); }
    playBonus() { this.playTone(800, 'square', 0.1, 0.1); setTimeout(() => this.playTone(1200, 'square', 0.2, 0.1), 100); }
    playScore() { this.playTone(400, 'sawtooth', 0.1, 0.1); setTimeout(() => this.playTone(600, 'sawtooth', 0.1, 0.1), 100); setTimeout(() => this.playTone(900, 'sawtooth', 0.4, 0.1), 200); }
    playNuke() { this.playNoise(0.5, 0.3); }
    playBunker() { this.playTone(150, 'square', 0.4, 0.2); }
    playError() { this.playTone(150, 'sawtooth', 0.2, 0.1); }
}

const STATE = {
    EMPTY: 0,
    P1: 1,      
    P2: 2,      
    P1_SCORED: 3,
    P2_SCORED: 4,
    P1_BUNKER: 5, 
    P2_BUNKER: 6,
    P1_BUNKER_SCORED: 7, 
    P2_BUNKER_SCORED: 8, 
    CRATER: 9
};

class Connect5 {
    constructor() {
        this.mapSize = 15;
        this.rows = this.mapSize;
        this.cols = this.mapSize;
        this.grid = [];
        this.currentPlayer = 1; 
        this.scores = { 1: 0, 2: 0 };
        this.nukes = { 1: 0, 2: 0 };    
        this.boosters = { 1: 0, 2: 0 };
        this.bunkers = { 1: 0, 2: 0 }; 
        
        this.gameActive = true;
        this.winningScore = 3;
        this.bonusTurn = false;
        this.ignoreIsolation = false; 
        
        this.targetingMode = false;
        this.boostActive = false; 
        
        this.lastMove = null; 

        this.boardElement = document.getElementById('board');
        this.statusText = document.getElementById('status-text');
        this.isoIndicator = document.getElementById('iso-indicator');
        this.toast = document.getElementById('toast');
        this.appRoot = document.getElementById('app-root');
        
        this.sound = new SoundSystem();
        
        this.init();
    }

    getPlayerId(state) {
        if (state === STATE.P1 || state === STATE.P1_SCORED || state === STATE.P1_BUNKER || state === STATE.P1_BUNKER_SCORED) return 1;
        if (state === STATE.P2 || state === STATE.P2_SCORED || state === STATE.P2_BUNKER || state === STATE.P2_BUNKER_SCORED) return 2;
        return 0;
    }

    init() {
        if (!this.loadGame()) this.createBoard();
        this.updateUI();
        this.checkIsolationAvailability(); 
        document.body.addEventListener('click', () => this.sound.init(), {once:true});
    }

    openSettings() { document.getElementById('settings-overlay').classList.add('visible'); }
    setScale(val) { this.appRoot.style.transform = `scale(${val})`; }
    setMapSize(size) {
        this.mapSize = size;
        this.rows = size;
        this.cols = size;
        this.resetRound(); 
        document.getElementById('settings-overlay').classList.remove('visible');
    }

    createBoard() {
        this.boardElement.innerHTML = '';
        this.boardElement.style.gridTemplateColumns = `repeat(${this.cols}, 1fr)`;
        this.grid = Array(this.rows).fill().map(() => Array(this.cols).fill(STATE.EMPTY));
        this.renderBoard();
    }

    renderBoard() {
        this.boardElement.innerHTML = '';
        this.boardElement.style.gridTemplateColumns = `repeat(${this.cols}, 1fr)`;
        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.r = r;
                cell.dataset.c = c;
                cell.onclick = () => this.handleInteraction(r, c);
                this.boardElement.appendChild(cell);
                this.updateCellVisual(r, c);
            }
        }
    }

    handleInteraction(r, c) {
        if (!this.gameActive) return;
        if (this.targetingMode) this.executeNuke(r, c);
        else this.executeMove(r, c);
    }

    executeMove(r, c) {
        if (this.grid[r][c] !== STATE.EMPTY) {
            if (this.grid[r][c] === STATE.CRATER) {
                this.showToast("SECTOR DESTROYED.");
                this.sound.playError();
            }
            return;
        }

        if (this.bonusTurn && !this.ignoreIsolation && !this.isIsolated(r, c)) {
            this.showToast("DEPLOYMENT ERROR: Bonus piece must be isolated.");
            this.sound.playError();
            return;
        }

        const prevMove = this.lastMove;
        this.grid[r][c] = this.currentPlayer === 1 ? STATE.P1 : STATE.P2;
        this.lastMove = {r, c};
        this.sound.playPlace();
        
        this.updateCellVisual(r, c); 
        if (prevMove) this.updateCellVisual(prevMove.r, prevMove.c); 

        this.resolveTurn(r, c);
    }

    resolveTurn(r, c) {
        const player = this.currentPlayer;
        
        const scored = this.checkScoring(r, c);
        
        if (this.checkBoardFull()) {
            this.endRound("FULL");
            return;
        }
        
        if (scored) {
            this.bonusTurn = false;
            this.ignoreIsolation = false;
            this.sound.playScore();
            if (this.scores[player] >= this.winningScore) {
                this.endRound("SCORE");
                return;
            }
            this.switchTurn(); 
            return;
        } 
        
        let patternMessages = [];
        let triggeredBonusThisAction = false;

        const plusCoords = this.checkForPlusPattern(r, c);
        if (plusCoords) {
            this.boosters[player]++;
            this.sound.playBunker();
            
            const bunkerState = player === 1 ? STATE.P1_BUNKER : STATE.P2_BUNKER;
            const bunkerScored = player === 1 ? STATE.P1_BUNKER_SCORED : STATE.P2_BUNKER_SCORED;

            plusCoords.forEach(({r, c}) => {
                const s = this.grid[r][c];
                const isScored = (s === STATE.P1_SCORED || s === STATE.P2_SCORED || s === STATE.P1_BUNKER_SCORED || s === STATE.P2_BUNKER_SCORED);
                const newState = isScored ? bunkerScored : bunkerState;
                const wasBunker = (s === STATE.P1_BUNKER || s === STATE.P2_BUNKER || s === STATE.P1_BUNKER_SCORED || s === STATE.P2_BUNKER_SCORED);
                if (!wasBunker) this.bunkers[player]++;
                this.grid[r][c] = newState;
                this.updateCellVisual(r, c);
                const cell = this.getCell(r, c);
                const piece = cell.querySelector('.piece');
                if(piece) piece.classList.add('forming'); 
            });
            patternMessages.push("BUNKERS ESTABLISHED");
        }

        // Only allow a bonus turn if one isn't ALREADY active (prevents stacking/infinite loops)
        if (!this.bonusTurn) {
            const squareCoords = this.checkForSquarePattern(r, c);
            if (squareCoords) {
                triggeredBonusThisAction = true;
                this.sound.playBonus();
                squareCoords.forEach(({r, c}) => {
                    const cell = this.getCell(r, c);
                    const piece = cell.querySelector('.piece');
                    if (piece) piece.classList.add('square-flash');
                });
                patternMessages.push(`BONUS TURN`);
            }
        }
        
        if (patternMessages.length > 0) {
            this.showToast(patternMessages.join(" + "));
            this.updateUI();
        }

        if (triggeredBonusThisAction) {
            this.bonusTurn = true;
            this.checkIsolationAvailability();
            this.updateUI();
            return; 
        }

        // If we were already in a bonus turn, it is now consumed
        if (this.bonusTurn) {
            this.bonusTurn = false;
            this.ignoreIsolation = false;
            this.switchTurn();
        } else {
            // Normal turn end
            this.switchTurn();
        }
    }

    switchTurn() {
        this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
        this.targetingMode = false;
        this.boostActive = false; 
        this.boardElement.classList.remove('targeting', 'targeting-boosted');
        this.updateUI();
        this.checkIsolationAvailability();
    }

    checkBoardFull() {
        return this.grid.every(row => row.every(cell => cell !== STATE.EMPTY));
    }

    checkIsolationAvailability() {
        if (!this.bonusTurn) {
            this.isoIndicator.textContent = "";
            this.isoIndicator.classList.remove('available');
            return;
        }

        let possible = false;
        for(let r=0; r<this.rows; r++){
            for(let c=0; c<this.cols; c++){
                if(this.grid[r][c] === STATE.EMPTY && this.isIsolated(r, c)) {
                    possible = true;
                    break;
                }
            }
            if(possible) break;
        }

        if (!possible) {
            this.ignoreIsolation = true; 
            this.isoIndicator.textContent = "ISOLATION: IMPOSSIBLE";
            this.isoIndicator.style.color = "var(--text-boost)";
            this.isoIndicator.classList.remove('available'); 
        } else {
            this.isoIndicator.textContent = "ISOLATION: POSSIBLE";
            this.isoIndicator.classList.add('available');
            this.isoIndicator.style.color = "";
        }
    }

    isIsolated(r, c) {
        for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const nr = r + dr;
                const nc = c + dc;
                if (this.isValid(nr, nc)) {
                    const s = this.grid[nr][nc];
                    if (s !== STATE.EMPTY && s !== STATE.CRATER) return false;
                }
            }
        }
        return true;
    }

    checkForSquarePattern(r, c) {
        const player = this.currentPlayer;
        const corners = [[-1, -1], [-1, 0], [0, -1], [0, 0]]; 
        for (let [dr, dc] of corners) {
            const tr = r + dr, tc = c + dc;
            let isSquare = true;
            let coords = [];
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 2; j++) {
                    const nr = tr + i, nc = tc + j;
                    if (!this.isValid(nr, nc)) { isSquare = false; break; }
                    if (this.getPlayerId(this.grid[nr][nc]) !== player) { isSquare = false; }
                    coords.push({r: nr, c: nc});
                }
            }
            if (isSquare) return coords;
        }
        return null;
    }

    checkForPlusPattern(r, c) {
        const player = this.currentPlayer;
        const bunkerState = player === 1 ? STATE.P1_BUNKER : STATE.P2_BUNKER;
        const bunkerScored = player === 1 ? STATE.P1_BUNKER_SCORED : STATE.P2_BUNKER_SCORED;
        const potentialCenters = [[0,0], [0,1], [0,-1], [1,0], [-1,0]];

        for (let [dr, dc] of potentialCenters) {
            const centerR = r + dr;
            const centerC = c + dc;
            if (this.isValid(centerR, centerC)) {
                const centerS = this.grid[centerR][centerC];
                if (centerS === bunkerState || centerS === bunkerScored) continue;
                if (this.getPlayerId(centerS) !== player) continue;
                const offsets = [[0,0], [0,1], [0,-1], [1,0], [-1,0]]; 
                const arms = [[0,1], [0,-1], [1,0], [-1,0]];
                const isPlus = arms.every(([ar, ac]) => {
                    const armR = centerR + ar;
                    const armC = centerC + ac;
                    if (!this.isValid(armR, armC)) return false;
                    return this.getPlayerId(this.grid[armR][armC]) === player;
                });
                if (isPlus) return offsets.map(([or, oc]) => ({r: centerR+or, c: centerC+oc}));
            }
        }
        return null;
    }

    checkScoring(r, c) {
        const player = this.currentPlayer;
        const directions = [[0,1], [1,0], [1,1], [1,-1]];
        let scored = false;
        const unscoredNormal = player === 1 ? STATE.P1 : STATE.P2;
        const unscoredBunker = player === 1 ? STATE.P1_BUNKER : STATE.P2_BUNKER;
        const isCountable = (s) => (s === unscoredNormal || s === unscoredBunker);

        const getLine = (dr, dc) => {
            const line = [];
            for(let i=1; i<5; i++) {
                const nr = r - dr*i, nc = c - dc*i;
                if (!this.isValid(nr, nc) || this.grid[nr][nc] === STATE.CRATER) break;
                line.unshift({r: nr, c: nc, state: this.grid[nr][nc]});
            }
            line.push({r, c, state: this.grid[r][c]});
            for(let i=1; i<5; i++) {
                const nr = r + dr*i, nc = c + dc*i;
                if (!this.isValid(nr, nc) || this.grid[nr][nc] === STATE.CRATER) break;
                line.push({r: nr, c: nc, state: this.grid[nr][nc]});
            }
            return line;
        };

        directions.forEach(([dr, dc]) => {
            const line = getLine(dr, dc);
            for(let i=0; i <= line.length - 5; i++) {
                const segment = line.slice(i, i+5);
                const count = segment.filter(p => isCountable(p.state)).length;
                if (count === 5) {
                    this.applyScore(segment);
                    scored = true;
                }
            }
        });
        return scored;
    }

    applyScore(segment) {
        this.scores[this.currentPlayer]++;
        const currentScore = this.scores[this.currentPlayer];
        if (currentScore === 1) {
            this.nukes[this.currentPlayer]++; 
            this.showToast("TARGET NEUTRALIZED. NUKE ARMED.");
        } else if (currentScore === 2) {
            const opponent = this.currentPlayer === 1 ? 2 : 1;
            this.nukes[opponent]++;
            this.showToast("WARNING: OPPONENT INTERCEPTED CODES. ENEMY GAINS NUKE.");
        }
        segment.forEach(p => {
            const s = this.grid[p.r][p.c];
            let nextState = s;
            if (this.currentPlayer === 1) {
                if (s === STATE.P1) nextState = STATE.P1_SCORED;
                if (s === STATE.P1_BUNKER) nextState = STATE.P1_BUNKER_SCORED;
            } else {
                if (s === STATE.P2) nextState = STATE.P2_SCORED;
                if (s === STATE.P2_BUNKER) nextState = STATE.P2_BUNKER_SCORED;
            }
            this.grid[p.r][p.c] = nextState;
            this.updateCellVisual(p.r, p.c);
        });
    }

    toggleTargeting() {
        if (!this.gameActive) return;
        if (this.nukes[this.currentPlayer] <= 0) {
            this.showToast("SILOS EMPTY.");
            this.sound.playError();
            return;
        }
        this.targetingMode = !this.targetingMode;
        this.updateUI(); 
        if (this.targetingMode) {
            this.sound.playPlace(); 
            if (this.boostActive) this.showToast("BOOSTED LAUNCH PRIMED.");
            else this.showToast("STANDARD LAUNCH PRIMED.");
        }
    }

    toggleBoost() {
        if (!this.gameActive) return;
        if (this.boosters[this.currentPlayer] <= 0) {
            this.showToast("NO BOOSTERS AVAILABLE.");
            this.sound.playError();
            return;
        }
        this.boostActive = !this.boostActive;
        this.sound.playPlace();
        this.updateUI();
    }

    executeNuke(r, c) {
        if (this.nukes[this.currentPlayer] < 1) return;
        if (!this.boostActive) {
            const s = this.grid[r][c];
            const p = this.currentPlayer;
            const owner = this.getPlayerId(s);
            if (owner !== p) {
                this.showToast("INVALID TARGET: ALLIED UNIT REQUIRED.");
                this.sound.playError();
                return;
            }
        }
        const affectedCells = [];
        const maxDist = this.boostActive ? 2 : 1;
        for(let dr = -maxDist; dr <= maxDist; dr++) {
            for(let dc = -maxDist; dc <= maxDist; dc++) {
                const dist = Math.abs(dr) + Math.abs(dc);
                if (dist <= maxDist) {
                    const nr = r + dr;
                    const nc = c + dc;
                    if (this.isValid(nr, nc)) {
                        const cell = this.getCell(nr, nc);
                        cell.classList.add('exploding');
                        affectedCells.push({r: nr, c: nc, cell});
                    }
                }
            }
        }
        this.sound.playNuke();
        document.querySelector('.board-container').classList.add('impact');
        setTimeout(() => {
            affectedCells.forEach(({r, c, cell}) => {
                const s = this.grid[r][c];
                const isBunker = (s === STATE.P1_BUNKER || s === STATE.P2_BUNKER || s === STATE.P1_BUNKER_SCORED || s === STATE.P2_BUNKER_SCORED);
                if (isBunker && !this.boostActive) {
                    cell.classList.remove('exploding');
                } else {
                    if (isBunker) {
                        const owner = this.getPlayerId(s);
                        if (owner > 0) this.bunkers[owner]--;
                    }
                    this.grid[r][c] = STATE.CRATER;
                    cell.classList.remove('exploding');
                    cell.innerHTML = ''; 
                    cell.className = 'cell crater';
                }
            });
            document.querySelector('.board-container').classList.remove('impact');
            this.nukes[this.currentPlayer]--;
            if (this.boostActive) this.boosters[this.currentPlayer]--;
            this.targetingMode = false;
            this.boostActive = false;
            this.bonusTurn = false;
            this.switchTurn();
        }, 350);
    }

    isValid(r, c) { return r >= 0 && r < this.rows && c >= 0 && c < this.cols; }
    getCell(r, c) { return this.boardElement.children[r * this.cols + c]; }

    updateCellVisual(r, c) {
        const cell = this.getCell(r, c);
        cell.className = 'cell';
        cell.innerHTML = '';
        const s = this.grid[r][c];
        if (s === STATE.CRATER) {
            cell.classList.add('crater');
        } else if (s !== STATE.EMPTY) {
            const p = document.createElement('div');
            p.className = 'piece';
            if (s === STATE.P1) p.classList.add('p1', 'placed');
            else if (s === STATE.P2) p.classList.add('p2', 'placed');
            else if (s === STATE.P1_SCORED) p.classList.add('p1', 'scored');
            else if (s === STATE.P2_SCORED) p.classList.add('p2', 'scored');
            else if (s === STATE.P1_BUNKER) p.classList.add('p1', 'bunker');
            else if (s === STATE.P2_BUNKER) p.classList.add('p2', 'bunker');
            else if (s === STATE.P1_BUNKER_SCORED) p.classList.add('p1', 'bunker', 'scored');
            else if (s === STATE.P2_BUNKER_SCORED) p.classList.add('p2', 'bunker', 'scored');
            if (this.lastMove && this.lastMove.r === r && this.lastMove.c === c) p.classList.add('last-move');
            cell.appendChild(p);
        }
        if (this.targetingMode && !this.boostActive) {
            const owner = this.getPlayerId(s);
            if (owner !== this.currentPlayer) cell.classList.add('invalid-target');
        }
    }

    updateUI() {
        const p1 = this.currentPlayer === 1;
        document.getElementById('p1-panel').classList.toggle('active-turn', p1);
        document.getElementById('p2-panel').classList.toggle('active-turn', !p1);
        document.getElementById('score1').textContent = this.scores[1];
        document.getElementById('score2').textContent = this.scores[2];
        document.getElementById('nuke1').textContent = this.nukes[1];
        document.getElementById('nuke2').textContent = this.nukes[2];
        document.getElementById('boost1').textContent = this.boosters[1];
        document.getElementById('boost2').textContent = this.boosters[2];
        document.getElementById('bunker1').textContent = this.bunkers[1];
        document.getElementById('bunker2').textContent = this.bunkers[2];
        let txt = p1 ? "COMMANDER A // AWAITING INPUT" : "COMMANDER B // AWAITING INPUT";
        let statusClass = "status-text";
        if (this.bonusTurn) {
            txt = "BONUS TURN ACTIVE";
            statusClass = "status-bonus";
        } else if (this.targetingMode) {
            txt = this.boostActive ? "TARGETING BOOSTED ICBM..." : "TARGETING STANDARD ICBM...";
            statusClass = "status-bonus"; 
        }
        this.statusText.textContent = txt;
        this.statusText.className = statusClass;
        const btnNuke = document.getElementById('btn-nuke');
        const btnBoost = document.getElementById('btn-boost');
        btnNuke.disabled = this.nukes[this.currentPlayer] <= 0;
        btnNuke.innerText = this.targetingMode ? "CANCEL" : "LAUNCH ICBM";
        btnNuke.classList.toggle('active', this.targetingMode);
        btnBoost.disabled = this.boosters[this.currentPlayer] <= 0 || this.nukes[this.currentPlayer] <= 0;
        btnBoost.classList.toggle('active', this.boostActive);
        this.boardElement.className = 'board';
        if (this.targetingMode) {
            this.boardElement.classList.add(this.boostActive ? 'targeting-boosted' : 'targeting');
            for(let r=0; r<this.rows; r++) for(let c=0; c<this.cols; c++) this.updateCellVisual(r,c);
        }
    }

    showToast(msg) {
        this.toast.textContent = msg;
        this.toast.classList.add('show');
        setTimeout(() => this.toast.classList.remove('show'), 2500);
    }

    saveGame() {
        localStorage.setItem('con5_v5_save', JSON.stringify({
            grid: this.grid, scores: this.scores, nukes: this.nukes, boosters: this.boosters, bunkers: this.bunkers,
            currentPlayer: this.currentPlayer, bonusTurn: this.bonusTurn, lastMove: this.lastMove, mapSize: this.mapSize
        }));
        this.showToast("SIMULATION SAVED");
        this.sound.playPlace();
    }

    loadGame() {
        const data = localStorage.getItem('con5_v5_save');
        if (!data) return false;
        try {
            const s = JSON.parse(data);
            this.mapSize = s.mapSize || 15;
            this.rows = this.mapSize;
            this.cols = this.mapSize;
            this.createBoard(); 
            this.grid = s.grid;
            this.scores = s.scores;
            this.nukes = s.nukes;
            this.boosters = s.boosters || {1:0, 2:0};
            this.bunkers = s.bunkers || {1:0, 2:0};
            this.currentPlayer = s.currentPlayer;
            this.bonusTurn = s.bonusTurn;
            this.lastMove = s.lastMove || null;
            this.renderBoard();
            this.updateUI();
            this.showToast("SIMULATION RESTORED");
            this.sound.playPlace();
            return true;
        } catch(e) { return false; }
    }

    resetRound() {
        this.gameActive = true;
        this.scores = {1:0, 2:0};
        this.nukes = {1:0, 2:0};
        this.boosters = {1:0, 2:0};
        this.bunkers = {1:0, 2:0};
        this.currentPlayer = 1;
        this.lastMove = null;
        this.bonusTurn = false;
        this.createBoard();
        this.updateUI();
        document.getElementById('overlay').classList.remove('visible');
        this.showToast("WAR GAMES INITIALIZED");
        this.sound.playPlace();
    }

    hideOverlay() { document.getElementById('overlay').classList.remove('visible'); }

    endRound(reason = "SCORE") {
        this.gameActive = false;
        let winner;
        let subtitle = "";
        if (reason === "SCORE") {
            winner = this.scores[1] >= 3 ? "COMMANDER A" : "COMMANDER B";
            subtitle = "VICTORY BY DOMINANCE (3 POINTS)";
        } else if (reason === "FULL") {
            if (this.scores[1] > this.scores[2]) winner = "COMMANDER A";
            else if (this.scores[2] > this.scores[1]) winner = "COMMANDER B";
            else {
                if (this.bunkers[1] > this.bunkers[2]) {
                    winner = "COMMANDER A";
                    subtitle = `TIE-BREAKER: BUNKERS (${this.bunkers[1]} vs ${this.bunkers[2]})`;
                } else if (this.bunkers[2] > this.bunkers[1]) {
                    winner = "COMMANDER B";
                    subtitle = `TIE-BREAKER: BUNKERS (${this.bunkers[2]} vs ${this.bunkers[1]})`;
                } else {
                    winner = "DRAW";
                    subtitle = "STALEMATE: SCORES AND BUNKERS TIED";
                }
            }
        }
        const title = winner === "DRAW" ? "SIMULATION HALTED" : `${winner} VICTORIOUS`;
        const h2 = document.getElementById('winner-title');
        h2.textContent = title;
        if(!h2.querySelector('.sub')) {
            const sub = document.createElement('div');
            sub.className = 'sub';
            sub.style.fontSize = "1rem";
            sub.style.marginTop = "10px";
            sub.style.opacity = "0.7";
            h2.appendChild(sub);
        }
        h2.querySelector('.sub').textContent = subtitle;
        document.getElementById('overlay').classList.add('visible');
    }
}

const game = new Connect5();
</script>
</body>
</html>
