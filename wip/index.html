<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect 5: War Room</title>
    <style>
        :root {
            --bg-color: #050a10;
            --panel-bg: rgba(10, 20, 30, 0.95);
            --grid-color: #1a3c5a;
            --text-main: #64d2ff;  /* Cyan */
            --text-sec: #ffaa00;   /* Amber */
            --text-alert: #ff3333; /* Red */
            --text-boost: #d946ef; /* Magenta */
            
            --p1-color: #00f0ff;   /* Neon Cyan */
            --p2-color: #ffaa00;   /* Neon Amber */
            
            --scored-p1: #00f0ff;  
            --scored-p2: #ffaa00;  
            
            --crater-bg: #000000;
            --border-style: 1px solid #1a3c5a;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--bg-color);
            background-image: 
                linear-gradient(rgba(5, 10, 16, 0.95), rgba(5, 10, 16, 0.95)),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.5) 3px);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            overflow-x: hidden;
            user-select: none;
        }

        .app-root {
            transition: transform 0.2s ease;
            transform-origin: top center;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        h1 {
            margin-bottom: 5px;
            font-size: 1.8rem;
            text-shadow: 0 0 5px var(--text-main);
            border-bottom: 2px solid var(--text-main);
            padding-bottom: 10px;
            width: 100%;
            max-width: 1000px;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .sim-header-right { font-size: 0.7rem; opacity: 0.7; }

        .game-wrapper {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
        }

        .side-panel {
            width: 200px;
            background: rgba(10, 20, 30, 0.6);
            border: 1px solid #334;
            padding: 15px;
            font-size: 0.7rem;
            color: #889;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .side-panel h3 {
            color: var(--text-main);
            border-bottom: 1px solid #334;
            margin: 0 0 8px 0;
            padding-bottom: 4px;
            font-size: 0.8rem;
        }

        .tut-item { 
            margin-bottom: 15px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .tut-label { color: #fff; font-weight: bold; display: block; margin-bottom: 6px; font-size: 0.75rem; }
        .tut-desc { line-height: 1.3; margin-top: 6px; color: #aaa; }

        .mini-grid {
            display: grid;
            gap: 2px;
            background: rgba(0,0,0,0.5);
            padding: 4px;
            border: 1px solid #334;
        }
        .mini-cell {
            width: 10px;
            height: 10px;
            background: #1a2a3a;
            border-radius: 50%;
        }
        .mini-cell.active {
            background: var(--text-main);
            box-shadow: 0 0 5px var(--text-main);
        }
        .grid-5row { grid-template-columns: repeat(5, 1fr); }
        .grid-2x2 { grid-template-columns: repeat(2, 1fr); }
        .grid-plus { grid-template-columns: repeat(3, 1fr); }

        @media (max-width: 1000px) {
            .side-panel { display: none; }
        }

        .game-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
        }

        .scoreboard {
            display: flex;
            gap: 15px;
            margin-bottom: 1rem;
            width: 100%;
        }

        .player-score {
            background: var(--panel-bg);
            border: var(--border-style);
            padding: 12px;
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            transition: all 0.3s;
        }

        .player-score.active-turn {
            border-color: currentColor;
            box-shadow: 0 0 20px rgba(255,255,255, 0.05);
        }
        
        .p1-panel { color: var(--p1-color); }
        .p2-panel { color: var(--p2-color); }

        .score-val {
            font-size: 2.5rem;
            font-weight: bold;
            line-height: 1;
            margin: 5px 0 10px 0;
            text-shadow: 0 0 10px currentColor;
        }

        .player-label { font-size: 0.75rem; font-weight: bold; margin-bottom: 5px; }

        .resources-row {
            display: flex;
            gap: 5px;
            width: 100%;
            justify-content: center;
        }

        .res-item {
            font-size: 0.7rem;
            border: 1px solid currentColor;
            background: rgba(0,0,0,0.3);
            text-align: center;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 4px 2px;
        }
        .res-val { font-size: 1rem; font-weight: bold; line-height: 1; }
        .res-icon { font-size: 0.9rem; margin-bottom: 2px; display: block; }

        .status-bar {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 0.85rem;
            font-weight: bold;
            min-height: 1.2em;
        }
        .status-text { animation: blink-slow 2s infinite; }
        .status-bonus { color: var(--text-boost); animation: blink-fast 0.5s infinite alternate; }
        
        .isolation-indicator {
            font-size: 0.7rem;
            padding: 2px 6px;
            border: 1px solid #333;
            color: #555;
            transition: all 0.3s;
        }
        .isolation-indicator.available {
            border-color: var(--text-main);
            color: var(--text-main);
            box-shadow: 0 0 5px rgba(100, 210, 255, 0.2);
        }
        
        @keyframes blink-slow { 50% { opacity: 0.6; } }
        @keyframes blink-fast { from { opacity: 1; text-shadow: 0 0 10px currentColor; } to { opacity: 0.5; } }

        .board-container {
            position: relative;
            padding: 4px;
            border: 1px solid var(--grid-color);
            background: rgba(0,0,0,0.5);
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        
        .board-container.impact { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-2px, 0, 0); } 20%, 80% { transform: translate3d(4px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-6px, 0, 0); } 40%, 60% { transform: translate3d(6px, 0, 0); } }

        .board {
            display: grid;
            width: min(90vw, 550px);
            height: min(90vw, 550px);
            background: transparent;
            border-top: 1px solid var(--grid-color);
            border-left: 1px solid var(--grid-color);
            cursor: crosshair;
        }
        
        .cell {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid var(--grid-color);
            border-bottom: 1px solid var(--grid-color);
            box-sizing: border-box; 
            overflow: hidden; 
        }
        
        .cell.crater {
            background: repeating-linear-gradient(
                45deg,
                #550000,
                #550000 5px,
                #000000 5px,
                #000000 10px
            );
            border: 1px solid #ff0000;
            box-shadow: inset 0 0 10px #ff0000;
        }

        .board.targeting .cell:hover { background: rgba(0, 255, 255, 0.1); box-shadow: inset 0 0 10px cyan; }
        .board.targeting .cell.invalid-target:hover { background: rgba(255, 0, 0, 0.2); box-shadow: inset 0 0 10px red; cursor: not-allowed; }
        .board.targeting-boosted .cell:hover { background: rgba(217, 70, 239, 0.2); box-shadow: inset 0 0 15px var(--text-boost); }

        .piece {
            width: 60%; height: 60%; border-radius: 50%;
            transition: all 0.2s; 
            box-sizing: border-box;
            box-shadow: 0 0 8px currentColor;
        }
        .piece.p1 { background-color: var(--p1-color); color: var(--p1-color); }
        .piece.p2 { background-color: var(--p2-color); color: var(--p2-color); }
        
        .piece.placed { animation: ping 0.4s ease-out; }
        @keyframes ping { 0% { box-shadow: 0 0 0 0 currentColor; } 100% { box-shadow: 0 0 0 15px transparent; } }

        .piece.last-move {
            box-shadow: 0 0 0 2px #fff, 0 0 15px #fff !important;
            z-index: 10;
        }

        .piece.scored { 
            background-color: transparent !important;
            box-shadow: 0 0 0 3px currentColor, 0 0 15px currentColor;
            width: 65%; height: 65%; 
        }
        .piece.p1.scored { color: var(--scored-p1); }
        .piece.p2.scored { color: var(--scored-p2); }

        .piece.square-flash {
            animation: flash-square 0.5s ease-out;
        }
        @keyframes flash-square {
            0% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.3); filter: brightness(2); box-shadow: 0 0 20px #fff; }
            100% { transform: scale(1); filter: brightness(1); }
        }

        .piece.bunker {
            border-radius: 10%; 
            width: 75%; height: 75%;
            background: repeating-linear-gradient(45deg, currentColor, currentColor 2px, transparent 2px, transparent 4px);
            box-shadow: 0 0 0 2px currentColor, 0 0 10px currentColor;
            z-index: 5;
        }
        .piece.bunker.scored {
            background: transparent !important;
            box-shadow: inset 0 0 0 3px currentColor, 0 0 10px currentColor;
        }
        .piece.bunker.forming { animation: bunker-lock 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes bunker-lock { 0% { transform: scale(1.2); opacity: 0.5; } 50% { transform: scale(0.8); } 100% { transform: scale(1); opacity: 1; } }

        .controls-area {
            width: 100%; margin-top: 15px;
            display: grid; grid-template-columns: 2fr 1fr; gap: 15px;
        }
        
        .panel { padding: 10px; border: 1px solid #333; background: rgba(0,0,0,0.5); }
        .panel h3 { margin: 0 0 10px 0; font-size: 0.7rem; color: #888; border-bottom: 1px solid #333; letter-spacing: 2px; }

        .btn-group { display: flex; gap: 8px; flex-wrap: wrap; }

        button {
            background: transparent; color: #888; border: 1px solid #444;
            padding: 8px 12px; font-family: inherit; font-size: 0.7rem; font-weight: bold;
            cursor: pointer; transition: all 0.2s; flex: 1; min-width: 80px;
        }
        button:hover:not(:disabled) { border-color: #fff; color: #fff; background: rgba(255,255,255,0.1); }
        button:disabled { opacity: 0.3; cursor: not-allowed; }

        .btn-nuke { color: var(--text-alert); border-color: var(--text-alert); }
        .btn-nuke:hover:not(:disabled) { background: rgba(255, 0, 0, 0.1); box-shadow: 0 0 10px rgba(255,0,0,0.4); }
        .btn-nuke.active { background: var(--text-alert); color: #000; }

        .btn-boost { color: var(--text-boost); border-color: var(--text-boost); }
        .btn-boost:hover:not(:disabled) { background: rgba(217, 70, 239, 0.1); box-shadow: 0 0 10px rgba(217, 70, 239, 0.4); }
        .btn-boost.active { background: var(--text-boost); color: #000; box-shadow: 0 0 15px var(--text-boost); animation: pulse-btn 1s infinite; }

        @keyframes pulse-btn { 0% { opacity: 1; } 50% { opacity: 0.8; transform: scale(0.98); } 100% { opacity: 1; } }

        .btn-system { border-color: #1a3c5a; }

        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); z-index: 100;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.5s;
        }
        .overlay.visible { opacity: 1; pointer-events: auto; }
        .modal { border: 2px solid var(--text-main); padding: 40px; text-align: center; background: #050a10; min-width: 300px;}
        .modal h2 { margin-top: 0; margin-bottom: 20px; font-size: 1.5rem; color: var(--text-main); }
        .modal-btn-group { display: flex; flex-direction: column; gap: 15px; }
        .btn-view-board { border-color: #666; color: #aaa; }
        
        .setting-row { margin-bottom: 20px; text-align: left; }
        .setting-label { display: block; margin-bottom: 10px; font-size: 0.8rem; color: #aaa; }
        .range-wrap { display: flex; align-items: center; gap: 10px; color: #aaa; font-size: 0.8rem; }
        input[type=range] { flex: 1; }

        .toast {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(10, 20, 30, 0.95); border: 1px solid var(--text-main);
            color: var(--text-main); padding: 10px 20px; font-size: 0.8rem;
            opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 200;
        }
        .toast.show { opacity: 1; }
    </style>
</head>
<body>

<div class="app-root" id="app-root">
    <h1>
        <span>WAR ROOM // SYMMETRIC</span>
        <span class="sim-header-right">V.6.4 [FIXED_INIT]</span>
    </h1>

    <div class="game-wrapper">
        <div class="side-panel">
            <h3>PATTERNS</h3>
            <div class="tut-item">
                <span class="tut-label">5-IN-ROW</span>
                <div class="mini-grid grid-5row">
                    <div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell active"></div>
                </div>
                <div class="tut-desc">Win a Point + Earn Nuke.</div>
            </div>
            <div class="tut-item">
                <span class="tut-label">2x2 SQUARE</span>
                <div class="mini-grid grid-2x2">
                    <div class="mini-cell active"></div><div class="mini-cell active"></div>
                    <div class="mini-cell active"></div><div class="mini-cell active"></div>
                </div>
                <div class="tut-desc">Bonus Turn (Must be isolated).</div>
            </div>
            <div class="tut-item">
                <span class="tut-label">PLUS (+)</span>
                <div class="mini-grid grid-plus">
                    <div class="mini-cell"></div><div class="mini-cell active"></div><div class="mini-cell"></div>
                    <div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell active"></div>
                    <div class="mini-cell"></div><div class="mini-cell active"></div><div class="mini-cell"></div>
                </div>
                <div class="tut-desc">Creates 5 Bunkers + Earn Booster.</div>
            </div>
        </div>

        <div class="game-center">
            <div class="scoreboard">
                <div class="player-score p1-panel" id="p1-panel">
                    <div class="player-label">COM-A (CYAN)</div>
                    <div class="score-val" id="score1">0</div>
                    <div class="resources-row">
                        <div class="res-item"><span class="res-icon">☢</span><span class="res-val" id="nuke1">0</span></div>
                        <div class="res-item"><span class="res-icon">⚡</span><span class="res-val" id="boost1">0</span></div>
                        <div class="res-item"><span class="res-icon">⛨</span><span class="res-val" id="bunker1">0</span></div>
                    </div>
                </div>
                
                <div class="player-score p2-panel" id="p2-panel">
                    <div class="player-label">COM-B (AMBER)</div>
                    <div class="score-val" id="score2">0</div>
                    <div class="resources-row">
                        <div class="res-item"><span class="res-icon">☢</span><span class="res-val" id="nuke2">0</span></div>
                        <div class="res-item"><span class="res-icon">⚡</span><span class="res-val" id="boost2">0</span></div>
                        <div class="res-item"><span class="res-icon">⛨</span><span class="res-val" id="bunker2">0</span></div>
                    </div>
                </div>
            </div>

            <div class="status-bar">
                <div id="status-text" class="status-text">INITIALIZING...</div>
                <div id="iso-indicator" class="isolation-indicator">ISOLATION: CHECKING</div>
            </div>

            <div class="board-container">
                <div class="board" id="board"></div>
            </div>

            <div class="controls-area">
                <div class="panel">
                    <h3>ARSENAL</h3>
                    <div class="btn-group">
                        <button id="btn-nuke" class="btn-nuke" onclick="game.uiToggleNuke()">LAUNCH ICBM</button>
                        <button id="btn-boost" class="btn-boost" onclick="game.uiToggleBoost()">ENGAGE BOOSTER</button>
                    </div>
                </div>
                <div class="panel">
                    <h3>SYSTEM</h3>
                    <div class="btn-group">
                        <button class="btn-system" onclick="game.openSettings()">SETTINGS</button>
                        <button class="btn-system" onclick="game.saveToLocal()">SAVE</button>
                        <button class="btn-system" onclick="game.loadFromLocal()">LOAD</button>
                        <button class="btn-system" onclick="game.resetRound()">RESET</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="side-panel">
            <h3>ORDNANCE</h3>
            <div class="tut-item"><span class="tut-label">BUNKERS</span><div class="tut-desc">Immune to Standard Nukes.</div></div>
            <div class="tut-item"><span class="tut-label">BOOSTED NUKE</span><div class="tut-desc">Radius 2. Destroys Bunkers.</div></div>
        </div>
    </div>
</div>

<div class="overlay" id="overlay">
    <div class="modal">
        <h2 id="winner-title">VICTORY</h2>
        <div class="modal-btn-group">
            <button class="btn-system" onclick="game.resetRound()">RESTART SIMULATION</button>
            <button class="btn-system" style="border-color:#666" onclick="document.getElementById('overlay').classList.remove('visible')">VIEW BOARD</button>
        </div>
    </div>
</div>

<div class="overlay" id="settings-overlay">
    <div class="modal">
        <h2>SYSTEM SETTINGS</h2>
        <div class="setting-row">
            <span class="setting-label">MAP SIZE</span>
            <div class="btn-group">
                <button onclick="game.setMapSize(13)">13x13</button>
                <button onclick="game.setMapSize(15)">15x15</button>
                <button onclick="game.setMapSize(19)">19x19</button>
            </div>
        </div>
        <div class="setting-row">
            <span class="setting-label">UI SCALE</span>
            <input type="range" min="0.7" max="1.3" step="0.1" value="1" oninput="game.setScale(this.value)">
        </div>
        <button class="btn-system" onclick="document.getElementById('settings-overlay').classList.remove('visible')">CLOSE</button>
    </div>
</div>
<div id="toast" class="toast"></div>

<script>
/**
* CONNECT 5: WAR ROOM v6.4
 * Refactored for Multiplayer capability.
 * All state changes now pass through applyMove().
 * FIXED INPUT HANDLING + MULTIPLAYER SAFE
*/

class SoundSystem {
    constructor() { this.ctx = null; }
    init() { if (!this.ctx) { const AC = window.AudioContext || window.webkitAudioContext; this.ctx = new AC(); } if (this.ctx.state === 'suspended') this.ctx.resume(); }
    playTone(f, t, d, v=0.1) {
        if (!this.ctx) return;
        const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
        o.type = t; o.frequency.setValueAtTime(f, this.ctx.currentTime);
        g.gain.setValueAtTime(v, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + d);
        o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime + d);
    }
    playNoise(d, v=0.2) {
        if (!this.ctx) return;
        const b = this.ctx.createBuffer(1, this.ctx.sampleRate * d, this.ctx.sampleRate);
        const data = b.getChannelData(0); for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
        const s = this.ctx.createBufferSource(); s.buffer = b;
        const g = this.ctx.createGain(); g.gain.setValueAtTime(v, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + d);
        s.connect(g); g.connect(this.ctx.destination); s.start();
    }
    playPlace() { this.playTone(600, 'sine', 0.1); }
    playBonus() { this.playTone(800, 'square', 0.1); setTimeout(() => this.playTone(1200, 'square', 0.2), 100); }
    playScore() { this.playTone(400, 'sawtooth', 0.1); setTimeout(() => this.playTone(600, 'sawtooth', 0.1), 100); setTimeout(() => this.playTone(900, 'sawtooth', 0.4), 200); }
    playNuke() { this.playNoise(0.5); }
    playBunker() { this.playTone(150, 'square', 0.4, 0.2); }
    playError() { this.playTone(150, 'sawtooth', 0.2); }
}

const STATE = { EMPTY: 0, P1: 1, P2: 2, P1_SCORED: 3, P2_SCORED: 4, P1_BUNKER: 5, P2_BUNKER: 6, P1_BUNKER_SCORED: 7, P2_BUNKER_SCORED: 8, CRATER: 9 };
// --- MULTIPLAYER CLIENT ---

let socket = null;
let multiplayerEnabled = false;

function initMultiplayer(gameInstance) {
try {
socket = new WebSocket("https://ticktack-nuke-server.onrender.com");

socket.onopen = () => {
            console.log("Connected to multiplayer server");
multiplayerEnabled = true;
gameInstance.showToast("MULTIPLAYER CONNECTED");
};

socket.onmessage = (event) => {
const data = JSON.parse(event.data);
            if (data.type === "state") {
                gameInstance.setState(data.state);
            }
            if (data.type === "state") gameInstance.setState(data.state);
};

        socket.onclose = () => {
            console.log("Disconnected from server");
            multiplayerEnabled = false;
            gameInstance.showToast("MULTIPLAYER DISCONNECTED");
        };
    } catch (e) {
        console.warn("Multiplayer unavailable");
    }
        socket.onclose = () => multiplayerEnabled = false;
}

class Connect5 {
constructor() {
        // Initial Constants
this.mapSize = 15;
        this.winningScore = 3;
        this.sound = new SoundSystem();
        
        // Volatile State (Capturable by getState)
        this.grid = [];
        this.grid = Array(this.mapSize).fill().map(()=>Array(this.mapSize).fill(STATE.EMPTY));
this.currentPlayer = 1;
        this.scores = { 1: 0, 2: 0 };
        this.nukes = { 1: 0, 2: 0 };
        this.boosters = { 1: 0, 2: 0 };
        this.bunkers = { 1: 0, 2: 0 };
        this.scores = {1:0,2:0};
        this.nukes = {1:0,2:0};
        this.boosters = {1:0,2:0};
        this.bunkers = {1:0,2:0};
this.bonusTurn = false;
this.ignoreIsolation = false;
this.lastMove = null;
this.gameActive = true;

        // UI-only state (Not shared via getState)
this.uiTargetingMode = false;
this.uiBoostActive = false;

        // UI Refs (Initialized in Constructor now)
        this.boardElement = document.getElementById('board');
        this.appRoot = document.getElementById('app-root');
        this.statusText = document.getElementById('status-text');
        this.isoIndicator = document.getElementById('iso-indicator');
        this.toast = document.getElementById('toast');
        this.boardElement = document.getElementById("board");
        this.statusText = document.getElementById("status-text");
        this.isoIndicator = document.getElementById("iso-indicator");
        this.toast = document.getElementById("toast");

        this.init();
    }

    init() {
        if (!this.loadFromLocal()) this.createBoard(this.mapSize);
        this.updateUI();
        this.checkIsolationAvailability();
        document.body.addEventListener('mousedown', () => this.sound.init(), {once:true});
    }

    // --- MULTIPLAYER CORE: STATE SERIALIZATION ---

    getState() {
        return {
            grid: JSON.parse(JSON.stringify(this.grid)),
            currentPlayer: this.currentPlayer,
            scores: { ...this.scores },
            nukes: { ...this.nukes },
            boosters: { ...this.boosters },
            bunkers: { ...this.bunkers },
            bonusTurn: this.bonusTurn,
            ignoreIsolation: this.ignoreIsolation,
            lastMove: this.lastMove ? { ...this.lastMove } : null,
            gameActive: this.gameActive,
            mapSize: this.mapSize
        };
    }

    setState(state) {
        this.grid = state.grid;
        this.currentPlayer = state.currentPlayer;
        this.scores = state.scores;
        this.nukes = state.nukes;
        this.boosters = state.boosters;
        this.bunkers = state.bunkers;
        this.bonusTurn = state.bonusTurn;
        this.ignoreIsolation = state.ignoreIsolation;
        this.lastMove = state.lastMove;
        this.gameActive = state.gameActive;
        this.mapSize = state.mapSize;

        // Refresh visuals
this.renderBoard();
this.updateUI();
        if (!this.gameActive) this.showEndScreen();
}

    // --- MULTIPLAYER CORE: ACTION HANDLING ---

    applyMove(move) {
    if (!this.gameActive) return;
    // ---------- INPUT FIX ----------
    handleCellClick(r, c) {
        if (!this.gameActive) return;

    // Local execution
    if (move.type === 'place') {
        this.internalExecutePlace(move.r, move.c);
    } else if (move.type === 'nuke') {
        this.internalExecuteNuke(move.r, move.c, move.boosted);
        if (this.uiTargetingMode) {
            this.applyMove({
                type: "nuke",
                r, c,
                boosted: this.uiBoostActive
            });
        } else {
            this.applyMove({
                type: "place",
                r, c
            });
        }
}

    this.updateUI();

    // Multiplayer sync
    if (multiplayerEnabled && socket?.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: "state",
            state: this.getState()
    // ---------- MULTIPLAYER CORE ----------
    getState() {
        return JSON.parse(JSON.stringify({
            grid:this.grid,
            currentPlayer:this.currentPlayer,
            scores:this.scores,
            nukes:this.nukes,
            boosters:this.boosters,
            bunkers:this.bunkers,
            bonusTurn:this.bonusTurn,
            ignoreIsolation:this.ignoreIsolation,
            lastMove:this.lastMove,
            gameActive:this.gameActive,
            mapSize:this.mapSize
}));
}
}

    uiToggleNuke() {
        if (this.nukes[this.currentPlayer] <= 0) { this.showToast("SILOS EMPTY"); this.sound.playError(); return; }
        this.uiTargetingMode = !this.uiTargetingMode;
        if (!this.uiTargetingMode) this.uiBoostActive = false;
        this.updateUI();
    }

    uiToggleBoost() {
        if (this.boosters[this.currentPlayer] <= 0) { this.showToast("NO BOOSTERS"); this.sound.playError(); return; }
        this.uiBoostActive = !this.uiBoostActive;
        if (!this.uiTargetingMode) this.uiTargetingMode = true; // Auto-enable nuke mode if boost clicked
    setState(s) {
        Object.assign(this, s);
        this.renderBoard();
this.updateUI();
}

    // --- INTERNAL LOGIC (Private to class) ---

    internalExecutePlace(r, c) {
        if (this.grid[r][c] !== STATE.EMPTY) { this.sound.playError(); return; }
        if (this.bonusTurn && !this.ignoreIsolation && !this.isIsolated(r, c)) {
            this.showToast("BONUS PIECE MUST BE ISOLATED");
            this.sound.playError();
            return;
        }

        const prevMove = this.lastMove;
        this.grid[r][c] = this.currentPlayer === 1 ? STATE.P1 : STATE.P2;
        this.lastMove = { r, c };
        this.sound.playPlace();
        
        this.updateCellVisual(r, c);
        if (prevMove) this.updateCellVisual(prevMove.r, prevMove.c);

        this.resolvePostMove(r, c);
    }

    internalExecuteNuke(r, c, boosted) {
        // Validation logic
        if (this.nukes[this.currentPlayer] < 1) return;
        if (boosted && this.boosters[this.currentPlayer] < 1) return;
        
        if (!boosted) {
            if (this.getPlayerId(this.grid[r][c]) !== this.currentPlayer) {
                this.showToast("INVALID TARGET: ALLIED UNIT REQUIRED");
                this.sound.playError();
                return;
            }
        }

        const affected = [];
        const radius = boosted ? 2 : 1;
        for (let dr = -radius; dr <= radius; dr++) {
            for (let dc = -radius; dc <= radius; dc++) {
                if (Math.abs(dr) + Math.abs(dc) <= radius && this.isValid(r+dr, c+dc)) {
                    affected.push({ r: r+dr, c: c+dc });
                }
            }
        }

        this.sound.playNuke();
        document.querySelector('.board-container').classList.add('impact');
        
        // Immediate state update (In multiplayer, we want results to be deterministic)
        affected.forEach(pos => {
            const s = this.grid[pos.r][pos.c];
            const isBunker = (s >= 5 && s <= 8);
            if (!isBunker || boosted) {
                const owner = this.getPlayerId(s);
                if (isBunker && owner > 0) this.bunkers[owner]--;
                this.grid[pos.r][pos.c] = STATE.CRATER;
            }
        });

        this.nukes[this.currentPlayer]--;
        if (boosted) this.boosters[this.currentPlayer]--;
        
        // Clear UI flags after successful move
        this.uiTargetingMode = false;
        this.uiBoostActive = false;
        this.bonusTurn = false;
        
        setTimeout(() => {
            document.querySelector('.board-container').classList.remove('impact');
            this.renderBoard();
            this.switchTurn();
        }, 350);
    }
    applyMove(move) {
        if (!this.gameActive) return;

    resolvePostMove(r, c) {
        const player = this.currentPlayer;
        const scored = this.checkScoring(r, c);
        
        if (this.checkBoardFull()) { this.endRound("FULL"); return; }
        if (scored) {
            this.bonusTurn = false;
            this.ignoreIsolation = false;
            this.sound.playScore();
            if (this.scores[player] >= this.winningScore) { this.endRound("SCORE"); return; }
        if (move.type === "place") {
            if (this.grid[move.r][move.c] !== STATE.EMPTY) return;
            this.grid[move.r][move.c] = this.currentPlayer === 1 ? STATE.P1 : STATE.P2;
            this.lastMove = {r:move.r,c:move.c};
this.switchTurn();
            return;
        }

        let triggers = [];
        let earnedBonus = false;

        const plus = this.checkForPlus(r, c);
        if (plus) {
            this.boosters[player]++;
            this.sound.playBunker();
            plus.forEach(pos => {
                const s = this.grid[pos.r][pos.c];
                const wasBunker = (s >= 5 && s <= 8);
                if (!wasBunker) this.bunkers[player]++;
                const scored = (s === 3 || s === 4 || s === 7 || s === 8);
                this.grid[pos.r][pos.c] = player === 1 ? (scored ? 7 : 5) : (scored ? 8 : 6);
                this.updateCellVisual(pos.r, pos.c);
                // Add forming animation class
                const cell = this.getCell(pos.r, pos.c);
                const piece = cell.querySelector('.piece');
                if (piece) piece.classList.add('forming');
            });
            triggers.push("BUNKERS ESTABLISHED");
}

        if (!this.bonusTurn) {
            const square = this.checkForSquare(r, c);
            if (square) {
                earnedBonus = true;
                this.sound.playBonus();
                square.forEach(pos => this.getCell(pos.r, pos.c).querySelector('.piece')?.classList.add('square-flash'));
                triggers.push("BONUS TURN");
            }
        }

        if (triggers.length) this.showToast(triggers.join(" + "));

        if (earnedBonus) {
            this.bonusTurn = true;
            this.checkIsolationAvailability(); // Check logic for next move
            return;
        } 
        
        if (this.bonusTurn) {
            // If we were in a bonus turn and didn't earn another, turn ends
            this.bonusTurn = false;
            this.ignoreIsolation = false;
            this.switchTurn();
        } else {
        if (move.type === "nuke") {
            if (this.nukes[this.currentPlayer] <= 0) return;
            this.grid[move.r][move.c] = STATE.CRATER;
            this.nukes[this.currentPlayer]--;
            this.uiTargetingMode = false;
            this.uiBoostActive = false;
this.switchTurn();
}
    }

    // --- LOGIC HELPERS ---

    switchTurn() {
        this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
        this.uiTargetingMode = false;
        this.uiBoostActive = false;
        this.checkIsolationAvailability();
        this.renderBoard();
this.updateUI();
    }

    getPlayerId(s) {
        if ([1,3,5,7].includes(s)) return 1;
        if ([2,4,6,8].includes(s)) return 2;
        return 0;
    }

    isValid(r, c) { return r >= 0 && r < this.mapSize && c >= 0 && c < this.mapSize; }

    isIsolated(r, c) {
        for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                if (this.isValid(r+dr, c+dc)) {
                    const s = this.grid[r+dr][c+dc];
                    if (s !== STATE.EMPTY && s !== STATE.CRATER) return false;
                }
            }
        }
        return true;
    }

    checkIsolationAvailability() {
        if (!this.bonusTurn) return;
        let possible = false;
        for (let r=0; r<this.mapSize; r++) {
            for (let c=0; c<this.mapSize; c++) {
                if (this.grid[r][c] === STATE.EMPTY && this.isIsolated(r, c)) { possible = true; break; }
            }
            if (possible) break;
        }
        this.ignoreIsolation = !possible;
    }

    checkForSquare(r, c) {
        const p = this.currentPlayer;
        const offsets = [[-1,-1], [-1,0], [0,-1], [0,0]];
        for (let [dr, dc] of offsets) {
            let match = true;
            let coords = [];
            for (let i=0; i<2; i++) {
                for (let j=0; j<2; j++) {
                    const nr = r+dr+i, nc = c+dc+j;
                    if (!this.isValid(nr, nc) || this.getPlayerId(this.grid[nr][nc]) !== p) { match = false; break; }
                    coords.push({r:nr, c:nc});
                }
                if (!match) break;
            }
            if (match) return coords;
        if (multiplayerEnabled && socket?.readyState === 1) {
            socket.send(JSON.stringify({type:"state",state:this.getState()}));
}
        return null;
}

    checkForPlus(r, c) {
        const p = this.currentPlayer;
        const potential = [[0,0], [0,1], [0,-1], [1,0], [-1,0]];
        for (let [dr, dc] of potential) {
            const cr = r+dr, cc = c+dc;
            if (!this.isValid(cr, cc)) continue;
            const cs = this.grid[cr][cc];
            if ([5,6,7,8].includes(cs)) continue; // Already bunker
            if (this.getPlayerId(cs) !== p) continue;
            const arms = [[0,1], [0,-1], [1,0], [-1,0]];
            if (arms.every(([ar, ac]) => this.isValid(cr+ar, cc+ac) && this.getPlayerId(this.grid[cr+ar][cc+ac]) === p)) {
                return [[0,0], ...arms].map(([ar, ac]) => ({ r: cr+ar, c: cc+ac }));
            }
        }
        return null;
    switchTurn() {
        this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
}

    checkScoring(r, c) {
        const p = this.currentPlayer;
        const directions = [[0,1], [1,0], [1,1], [1,-1]];
        let found = false;
        directions.forEach(([dr, dc]) => {
            let line = [];
            for (let i=-4; i<=4; i++) {
                const nr = r+dr*i, nc = c+dc*i;
                if (this.isValid(nr, nc)) line.push({ r: nr, c: nc, s: this.grid[nr][nc] });
            }
            for (let i=0; i <= line.length - 5; i++) {
                const seg = line.slice(i, i+5);
                if (seg.every(cell => this.getPlayerId(cell.s) === p && ![3,4,7,8].includes(cell.s))) {
                    this.applyScoreSegment(seg);
                    found = true;
    // ---------- UI ----------
    renderBoard() {
        this.boardElement.innerHTML = "";
        this.boardElement.style.gridTemplateColumns = `repeat(${this.mapSize},1fr)`;

        for (let r=0;r<this.mapSize;r++) {
            for (let c=0;c<this.mapSize;c++) {
                const cell = document.createElement("div");
                cell.className = "cell";
                cell.onclick = () => this.handleCellClick(r,c);

                const s = this.grid[r][c];
                if (s !== STATE.EMPTY && s !== STATE.CRATER) {
                    const p = document.createElement("div");
                    p.className = "piece " + (s===1?"p1":"p2");
                    cell.appendChild(p);
}
            }
        });
        return found;
    }

    applyScoreSegment(seg) {
        this.scores[this.currentPlayer]++;
        if (this.scores[this.currentPlayer] === 1) this.nukes[this.currentPlayer]++;
        else if (this.scores[this.currentPlayer] === 2) this.nukes[this.currentPlayer === 1 ? 2 : 1]++;
        
        seg.forEach(cell => {
            const s = this.grid[cell.r][cell.c];
            if (s === 1) this.grid[cell.r][cell.c] = 3;
            else if (s === 2) this.grid[cell.r][cell.c] = 4;
            else if (s === 5) this.grid[cell.r][cell.c] = 7;
            else if (s === 6) this.grid[cell.r][cell.c] = 8;
            this.updateCellVisual(cell.r, cell.c);
        });
    }
                if (s === STATE.CRATER) cell.classList.add("crater");

    checkBoardFull() { return this.grid.every(row => row.every(c => c !== STATE.EMPTY)); }

    // --- UI RENDERERS ---

    createBoard(size) {
        this.mapSize = size;
        this.grid = Array(size).fill().map(() => Array(size).fill(0));
        this.renderBoard();
    }

    renderBoard() {
        if (!this.boardElement) return;
        this.boardElement.innerHTML = '';
        this.boardElement.style.gridTemplateColumns = `repeat(${this.mapSize}, 1fr)`;
        for (let r=0; r<this.mapSize; r++) {
            for (let c=0; c<this.mapSize; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.onclick = () => this.handleCellClick(r, c);
this.boardElement.appendChild(cell);
                this.updateCellVisual(r, c);
}
}
}

    updateCellVisual(r, c, animateBunker = false) {
        const cell = this.getCell(r, c);
        if (!cell) return;
        const s = this.grid[r][c];
        cell.className = 'cell';
        cell.innerHTML = '';
        if (s === STATE.CRATER) { cell.classList.add('crater'); return; }
        if (s === STATE.EMPTY) {
            if (this.uiTargetingMode && !this.uiBoostActive) cell.classList.add('invalid-target');
            return;
        }

        const p = document.createElement('div');
        p.className = 'piece';
        const owner = this.getPlayerId(s);
        p.classList.add(owner === 1 ? 'p1' : 'p2');
        if ([3,4,7,8].includes(s)) p.classList.add('scored');
        if ([5,6,7,8].includes(s)) p.classList.add('bunker');
        if (this.lastMove?.r === r && this.lastMove?.c === c) p.classList.add('last-move');
        cell.appendChild(p);

        if (this.uiTargetingMode && !this.uiBoostActive && owner !== this.currentPlayer) {
            cell.classList.add('invalid-target');
        }
    }

    getCell(r, c) { return this.boardElement?.children[r * this.mapSize + c]; }

updateUI() {
        const p = this.currentPlayer;
        document.getElementById('p1-panel').classList.toggle('active-turn', p === 1);
        document.getElementById('p2-panel').classList.toggle('active-turn', p === 2);
        document.getElementById('score1').textContent = this.scores[1];
        document.getElementById('score2').textContent = this.scores[2];
        document.getElementById('nuke1').textContent = this.nukes[1];
        document.getElementById('nuke2').textContent = this.nukes[2];
        document.getElementById('boost1').textContent = this.boosters[1];
        document.getElementById('boost2').textContent = this.boosters[2];
        document.getElementById('bunker1').textContent = this.bunkers[1];
        document.getElementById('bunker2').textContent = this.bunkers[2];

        let txt = p === 1 ? "COMMANDER A // AWAITING INPUT" : "COMMANDER B // AWAITING INPUT";
        let statusClass = "status-text";
        if (this.bonusTurn) { txt = "BONUS TURN ACTIVE"; statusClass = "status-bonus"; }
        else if (this.uiTargetingMode) { txt = this.uiBoostActive ? "TARGETING BOOSTED ICBM..." : "TARGETING STANDARD ICBM..."; statusClass = "status-bonus"; }
        
        this.statusText.textContent = txt;
        this.statusText.className = statusClass;

        const iso = this.isoIndicator;
        if (this.bonusTurn) {
            iso.textContent = this.ignoreIsolation ? "ISO: IMPOSSIBLE" : "ISO: REQUIRED";
            iso.classList.toggle('available', this.bonusTurn && !this.ignoreIsolation);
        } else {
            iso.textContent = "";
        }

        const bn = document.getElementById('btn-nuke');
        bn.disabled = this.nukes[p] <= 0;
        bn.innerText = this.uiTargetingMode ? "CANCEL" : "LAUNCH ICBM";
        bn.classList.toggle('active', this.uiTargetingMode);

        const bb = document.getElementById('btn-boost');
        bb.disabled = this.boosters[p] <= 0;
        bb.classList.toggle('active', this.uiBoostActive);

        if (this.boardElement) {
            this.boardElement.className = 'board';
            if (this.uiTargetingMode) this.boardElement.classList.add(this.uiBoostActive ? 'targeting-boosted' : 'targeting');
        }
    }

    showToast(m) {
        const t = this.toast;
        t.textContent = m; t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 2000);
        this.statusText.textContent =
            this.uiTargetingMode ? "TARGETING..." :
            this.currentPlayer === 1 ? "COMMANDER A TURN" : "COMMANDER B TURN";
}

    endRound(reason) {
        this.gameActive = false;
        this.showEndScreen(reason);
    }

    showEndScreen(reason) {
        const h2 = document.getElementById('winner-title');
        let win = "DRAW";
        if (this.scores[1] > this.scores[2]) win = "COMMANDER A";
        else if (this.scores[2] > this.scores[1]) win = "COMMANDER B";
        else if (this.bunkers[1] > this.bunkers[2]) win = "COMMANDER A (BUNKERS)";
        else if (this.bunkers[2] > this.bunkers[1]) win = "COMMANDER B (BUNKERS)";
        h2.textContent = win === "DRAW" ? "STALEMATE" : `${win} VICTORIOUS`;
        document.getElementById('overlay').classList.add('visible');
    uiToggleNuke() {
        if (this.nukes[this.currentPlayer] <= 0) return;
        this.uiTargetingMode = !this.uiTargetingMode;
        this.updateUI();
}

    resetRound() {
        this.scores = {1:0, 2:0}; this.nukes = {1:0, 2:0}; this.boosters = {1:0, 2:0}; this.bunkers = {1:0, 2:0};
        this.currentPlayer = 1; this.bonusTurn = false; this.lastMove = null; this.gameActive = true;
        this.uiTargetingMode = false; this.uiBoostActive = false;
        this.createBoard(this.mapSize);
    uiToggleBoost() {
        if (this.boosters[this.currentPlayer] <= 0) return;
        this.uiBoostActive = !this.uiBoostActive;
        this.uiTargetingMode = true;
this.updateUI();
        document.getElementById('overlay').classList.remove('visible');
}

    setMapSize(s) { this.mapSize = s; this.resetRound(); document.getElementById('settings-overlay').classList.remove('visible'); }
    setScale(v) { document.getElementById('app-root').style.transform = `scale(${v})`; }
    openSettings() { document.getElementById('settings-overlay').classList.add('visible'); }
    hideOverlay() { document.getElementById('overlay').classList.remove('visible'); }

    saveToLocal() { localStorage.setItem('con5_v6_save', JSON.stringify(this.getState())); this.showToast("LOCAL STATE SAVED"); }
    loadFromLocal() { const s = localStorage.getItem('con5_v6_save'); if (s) { this.setState(JSON.parse(s)); this.showToast("LOCAL STATE LOADED"); return true; } return false; }
    showToast(msg) {
        this.toast.textContent = msg;
        this.toast.classList.add("show");
        setTimeout(()=>this.toast.classList.remove("show"),2000);
    }
}

const game = new Connect5();
initMultiplayer(game);
</script>
</body>
</html>
