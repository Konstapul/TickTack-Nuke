<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect 5: War Room</title>
    <style>
        :root {
            --bg-color: #050a10;
            --panel-bg: rgba(10, 20, 30, 0.95);
            --grid-color: #1a3c5a;
            --text-main: #64d2ff;  /* Cyan */
            --text-sec: #ffaa00;   /* Amber */
            --text-alert: #ff3333; /* Red */
            --text-boost: #d946ef; /* Magenta */
            
            --p1-color: #00f0ff;   /* Neon Cyan */
            --p2-color: #ffaa00;   /* Neon Amber */
            
            --scored-p1: #00f0ff;  
            --scored-p2: #ffaa00;  
            
            --crater-bg: #000000;
            --border-style: 1px solid #1a3c5a;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--bg-color);
            background-image: 
                linear-gradient(rgba(5, 10, 16, 0.95), rgba(5, 10, 16, 0.95)),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.5) 3px);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            overflow-x: hidden;
            user-select: none;
        }

        .app-root {
            transition: transform 0.2s ease;
            transform-origin: top center;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        h1 {
            margin-bottom: 5px;
            font-size: 1.8rem;
            text-shadow: 0 0 5px var(--text-main);
            border-bottom: 2px solid var(--text-main);
            padding-bottom: 10px;
            width: 100%;
            max-width: 1000px;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .sim-header-right { font-size: 0.7rem; opacity: 0.7; display: flex; gap: 15px; align-items: center; }
        .connection-status { display: flex; align-items: center; gap: 5px; font-size: 0.7rem; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #333; box-shadow: 0 0 5px #333; transition: all 0.3s; }
        .status-dot.connected { background: #22c55e; box-shadow: 0 0 8px #22c55e; }
        .status-dot.connecting { background: #eab308; animation: blink-slow 1s infinite; }
        .status-dot.disconnected { background: #ef4444; }

        .game-wrapper {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
        }

        .side-panel {
            width: 220px;
            background: rgba(10, 20, 30, 0.6);
            border: 1px solid #334;
            padding: 15px;
            font-size: 0.7rem;
            color: #889;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .side-panel h3 {
            color: var(--text-main);
            border-bottom: 1px solid #334;
            margin: 0 0 8px 0;
            padding-bottom: 4px;
            font-size: 0.8rem;
        }

        .tut-item { margin-bottom: 10px; text-align: center; display: flex; flex-direction: column; align-items: center; }
        .tut-label { color: #fff; font-weight: bold; display: block; margin-bottom: 4px; font-size: 0.75rem; }
        .tut-desc { line-height: 1.3; margin-top: 4px; color: #aaa; }

        /* Chat/Log Styles */
        .chat-container {
            display: flex; flex-direction: column; height: 200px;
            border: 1px solid #334; background: rgba(0,0,0,0.3);
        }
        .chat-log {
            flex: 1; overflow-y: auto; padding: 5px; font-size: 0.65rem;
            display: flex; flex-direction: column; gap: 4px;
            scrollbar-width: thin; scrollbar-color: #334 #000;
        }
        .chat-msg { word-break: break-word; }
        .chat-msg.system { color: #aaa; font-style: italic; }
        .chat-msg.p1 { color: var(--p1-color); }
        .chat-msg.p2 { color: var(--p2-color); }
        .chat-input-area { display: flex; border-top: 1px solid #334; }
        .chat-input {
            flex: 1; background: transparent; border: none; color: #fff;
            padding: 5px; font-family: inherit; font-size: 0.7rem; outline: none;
        }
        .chat-btn { border: none; border-left: 1px solid #334; width: 40px; color: var(--text-main); }

        /* Room ID Input */
        .room-controls { display: flex; gap: 5px; margin-bottom: 10px; align-items: center; }
        .room-input {
            background: rgba(0,0,0,0.3); border: 1px solid #334; color: var(--text-main);
            padding: 4px; font-family: inherit; font-size: 0.7rem; width: 100px; text-align: center;
        }

        .mini-grid {
            display: grid; gap: 2px; background: rgba(0,0,0,0.5);
            padding: 4px; border: 1px solid #334; justify-content: center;
            width: max-content; /* Fix: prevents stretching in flex container */
            margin: 0 auto;
        }
        .mini-cell { width: 10px; height: 10px; background: #1a2a3a; border-radius: 50%; }
        .mini-cell.active { background: var(--text-main); box-shadow: 0 0 5px var(--text-main); }
        .grid-5row { grid-template-columns: repeat(5, 1fr); }
        .grid-2x2 { grid-template-columns: repeat(2, 1fr); }
        .grid-plus { grid-template-columns: repeat(3, 1fr); }

        @media (max-width: 1000px) { .side-panel { display: none; } }

        .game-center { display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 600px; }

        .scoreboard { display: flex; gap: 15px; margin-bottom: 1rem; width: 100%; }
        .player-score {
            background: var(--panel-bg); border: var(--border-style); padding: 12px;
            flex: 1; display: flex; flex-direction: column; align-items: center;
            position: relative; transition: all 0.3s; opacity: 0.7;
        }
        .player-score.active-turn {
            border-color: currentColor; opacity: 1; z-index: 10;
            box-shadow: 0 0 25px rgba(255,255,255, 0.15), inset 0 0 10px rgba(255,255,255,0.05); transform: scale(1.02);
        }
        .p1-panel { color: var(--p1-color); }
        .p2-panel { color: var(--p2-color); }
        .score-val { font-size: 2.5rem; font-weight: bold; margin: 5px 0 10px 0; text-shadow: 0 0 10px currentColor; }
        .player-label { font-size: 0.75rem; font-weight: bold; margin-bottom: 5px; }

        .resources-row { display: flex; gap: 5px; width: 100%; justify-content: center; }
        .res-item {
            font-size: 0.7rem; border: 1px solid currentColor; background: rgba(0,0,0,0.3);
            text-align: center; flex: 1; display: flex; flex-direction: column; justify-content: center; padding: 4px 2px;
        }
        .res-val { font-size: 1rem; font-weight: bold; line-height: 1; }
        .res-icon { font-size: 0.9rem; margin-bottom: 2px; display: block; }

        .status-bar { width: 100%; display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; font-size: 0.85rem; font-weight: bold; min-height: 1.2em; }
        .status-text { animation: blink-slow 2s infinite; }
        .status-bonus { color: var(--text-boost); animation: blink-fast 0.5s infinite alternate; }
        
        .isolation-indicator { font-size: 0.7rem; padding: 2px 6px; border: 1px solid #333; color: #555; transition: all 0.3s; }
        .isolation-indicator.available { border-color: var(--text-main); color: var(--text-main); box-shadow: 0 0 5px rgba(100, 210, 255, 0.2); }
        
        @keyframes blink-slow { 50% { opacity: 0.6; } }
        @keyframes blink-fast { from { opacity: 1; text-shadow: 0 0 10px currentColor; } to { opacity: 0.5; } }

        .board-container { position: relative; padding: 4px; border: 1px solid var(--grid-color); background: rgba(0,0,0,0.5); box-shadow: 0 0 30px rgba(0,0,0,0.8); }
        .board-container.impact { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-2px, 0, 0); } 20%, 80% { transform: translate3d(4px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-6px, 0, 0); } 40%, 60% { transform: translate3d(6px, 0, 0); } }

        .board { display: grid; width: min(90vw, 550px); height: min(90vw, 550px); background: transparent; border-top: 1px solid var(--grid-color); border-left: 1px solid var(--grid-color); cursor: crosshair; }
        
        .cell { position: relative; display: flex; align-items: center; justify-content: center; border-right: 1px solid var(--grid-color); border-bottom: 1px solid var(--grid-color); box-sizing: border-box; overflow: hidden; }
        .cell.crater { background: repeating-linear-gradient(45deg, #550000, #550000 5px, #000000 5px, #000000 10px); border: 1px solid #ff0000; box-shadow: inset 0 0 10px #ff0000; }
        
        /* Red highlight for invalid isolation spots (including occupied ones during bonus turn) */
        .cell.invalid-isolation { background: rgba(255, 50, 50, 0.2); box-shadow: inset 0 0 5px rgba(255, 0, 0, 0.4); }

        .board.targeting .cell:hover { background: rgba(0, 255, 255, 0.1); box-shadow: inset 0 0 10px cyan; }
        .board.targeting .cell.invalid-target:hover { background: rgba(255, 0, 0, 0.2); box-shadow: inset 0 0 10px red; cursor: not-allowed; }
        .board.targeting-boosted .cell:hover { background: rgba(217, 70, 239, 0.2); box-shadow: inset 0 0 15px var(--text-boost); }

        .piece { width: 60%; height: 60%; border-radius: 50%; transition: all 0.2s; box-sizing: border-box; box-shadow: 0 0 8px currentColor; pointer-events: none; }
        .piece.p1 { background-color: var(--p1-color); color: var(--p1-color); }
        .piece.p2 { background-color: var(--p2-color); color: var(--p2-color); }
        .piece.placed { animation: ping 0.4s ease-out; }
        @keyframes ping { 0% { box-shadow: 0 0 0 0 currentColor; } 100% { box-shadow: 0 0 0 15px transparent; } }

        .piece.last-move { box-shadow: 0 0 0 2px #fff, 0 0 15px #fff !important; z-index: 10; }
        .piece.scored { background-color: transparent !important; box-shadow: 0 0 0 3px currentColor, 0 0 15px currentColor; width: 65%; height: 65%; }
        .piece.p1.scored { color: var(--scored-p1); }
        .piece.p2.scored { color: var(--scored-p2); }
        .piece.square-flash { animation: flash-square 0.5s ease-out; }
        @keyframes flash-square { 0% { transform: scale(1); filter: brightness(1); } 50% { transform: scale(1.3); filter: brightness(2); box-shadow: 0 0 20px #fff; } 100% { transform: scale(1); filter: brightness(1); } }

        .piece.bunker { border-radius: 10%; width: 75%; height: 75%; background: repeating-linear-gradient(45deg, currentColor, currentColor 2px, transparent 2px, transparent 4px); box-shadow: 0 0 0 2px currentColor, 0 0 10px currentColor; z-index: 5; }
        .piece.bunker.scored { background: transparent !important; box-shadow: inset 0 0 0 3px currentColor, 0 0 10px currentColor; }
        .piece.bunker.forming { animation: bunker-lock 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes bunker-lock { 0% { transform: scale(1.2); opacity: 0.5; } 50% { transform: scale(0.8); } 100% { transform: scale(1); opacity: 1; } }

        .controls-area { width: 100%; margin-top: 15px; display: grid; grid-template-columns: 2fr 1fr; gap: 15px; }
        .panel { padding: 10px; border: 1px solid #333; background: rgba(0,0,0,0.5); }
        .panel h3 { margin: 0 0 10px 0; font-size: 0.7rem; color: #888; border-bottom: 1px solid #333; letter-spacing: 2px; }

        .btn-group { display: flex; gap: 8px; flex-wrap: wrap; }
        button { background: transparent; color: #888; border: 1px solid #444; padding: 8px 12px; font-family: inherit; font-size: 0.7rem; font-weight: bold; cursor: pointer; transition: all 0.2s; flex: 1; min-width: 80px; }
        button:hover:not(:disabled) { border-color: #fff; color: #fff; background: rgba(255,255,255,0.1); }
        button:disabled { opacity: 0.3; cursor: not-allowed; }
        .btn-nuke { color: var(--text-alert); border-color: var(--text-alert); }
        .btn-nuke:hover:not(:disabled) { background: rgba(255, 0, 0, 0.1); box-shadow: 0 0 10px rgba(255,0,0,0.4); }
        .btn-nuke.active { background: var(--text-alert); color: #000; }
        .btn-boost { color: var(--text-boost); border-color: var(--text-boost); }
        .btn-boost:hover:not(:disabled) { background: rgba(217, 70, 239, 0.1); box-shadow: 0 0 10px rgba(217, 70, 239, 0.4); }
        .btn-boost.active { background: var(--text-boost); color: #000; box-shadow: 0 0 15px var(--text-boost); animation: pulse-btn 1s infinite; }
        @keyframes pulse-btn { 0% { opacity: 1; } 50% { opacity: 0.8; transform: scale(0.98); } 100% { opacity: 1; } }
        .btn-system { border-color: #1a3c5a; }

        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 100; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.5s; }
        .overlay.visible { opacity: 1; pointer-events: auto; }
        .modal { border: 2px solid var(--text-main); padding: 40px; text-align: center; background: #050a10; min-width: 300px;}
        .modal h2 { margin-top: 0; margin-bottom: 20px; font-size: 1.5rem; color: var(--text-main); }
        .modal-btn-group { display: flex; flex-direction: column; gap: 15px; }
        .btn-view-board { border-color: #666; color: #aaa; }
        .setting-row { margin-bottom: 20px; text-align: left; }
        .setting-label { display: block; margin-bottom: 10px; font-size: 0.8rem; color: #aaa; }
        .range-wrap { display: flex; align-items: center; gap: 10px; color: #aaa; font-size: 0.8rem; }
        input[type=range] { flex: 1; }

        .toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); background: rgba(10, 20, 30, 0.95); border: 1px solid var(--text-main); color: var(--text-main); padding: 10px 20px; font-size: 0.8rem; opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 200; }
        .toast.show { opacity: 1; }
    </style>
</head>
<body>

<div class="app-root" id="app-root">

    <h1>
        <span>WAR ROOM // SYMMETRIC</span>
        <div class="sim-header-right">
            <div class="connection-status">
                <div id="conn-dot" class="status-dot disconnected"></div>
                <span id="conn-text">OFFLINE</span>
            </div>
            <span>V.7.2 [VISUAL_POLISH]</span>
        </div>
    </h1>

    <div class="game-wrapper">
        
        <div class="side-panel">
            <h3>PATTERNS</h3>
            <div class="tut-item"><span class="tut-label">5-IN-ROW</span><div class="mini-grid grid-5row"><div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell active"></div></div><div class="tut-desc">Win a Point.</div></div>
            <div class="tut-item"><span class="tut-label">2x2 SQUARE</span><div class="mini-grid grid-2x2"><div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell active"></div></div><div class="tut-desc">Bonus Turn.</div></div>
            <div class="tut-item"><span class="tut-label">PLUS (+)</span><div class="mini-grid grid-plus"><div class="mini-cell"></div><div class="mini-cell active"></div><div class="mini-cell"></div><div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell active"></div><div class="mini-cell"></div><div class="mini-cell active"></div><div class="mini-cell"></div></div><div class="tut-desc">Creates 5 Bunkers + Earn Booster.</div></div>
            
            <h3>COMMUNICATIONS</h3>
            <div class="room-controls">
                <label>ROOM:</label>
                <input type="text" id="room-input" class="room-input" onchange="game.joinRoom(this.value)">
            </div>
            <div class="chat-container">
                <div id="chat-log" class="chat-log"></div>
                <div class="chat-input-area">
                    <input type="text" id="chat-input" class="chat-input" placeholder="Transmit...">
                    <button class="chat-btn" onclick="game.sendChatFromInput()">></button>
                </div>
            </div>
        </div>

        <div class="game-center">
            <div class="scoreboard">
                <div class="player-score p1-panel" id="p1-panel">
                    <div class="player-label">COM-A (CYAN)</div><div class="score-val" id="score1">0</div>
                    <div class="resources-row">
                        <div class="res-item"><span class="res-icon">☢</span><span class="res-val" id="nuke1">0</span></div>
                        <div class="res-item"><span class="res-icon">⚡</span><span class="res-val" id="boost1">0</span></div>
                        <div class="res-item"><span class="res-icon">⛨</span><span class="res-val" id="bunker1">0</span></div>
                    </div>
                </div>
                <div class="player-score p2-panel" id="p2-panel">
                    <div class="player-label">COM-B (AMBER)</div><div class="score-val" id="score2">0</div>
                    <div class="resources-row">
                        <div class="res-item"><span class="res-icon">☢</span><span class="res-val" id="nuke2">0</span></div>
                        <div class="res-item"><span class="res-icon">⚡</span><span class="res-val" id="boost2">0</span></div>
                        <div class="res-item"><span class="res-icon">⛨</span><span class="res-val" id="bunker2">0</span></div>
                    </div>
                </div>
            </div>

            <div class="status-bar">
                <div id="status-text" class="status-text">INITIALIZING...</div>
                <div id="iso-indicator" class="isolation-indicator">CHECKING</div>
            </div>

            <div class="board-container">
                <div class="board" id="board"></div>
            </div>

            <div class="controls-area">
                <div class="panel">
                    <h3>ARSENAL</h3>
                    <div class="btn-group">
                        <button id="btn-nuke" class="btn-nuke" onclick="game.uiToggleNuke()">LAUNCH ICBM</button>
                        <button id="btn-boost" class="btn-boost" onclick="game.uiToggleBoost()">ENGAGE BOOSTER</button>
                    </div>
                </div>
                <div class="panel">
                    <h3>SYSTEM</h3>
                    <div class="btn-group">
                        <button class="btn-system" onclick="game.openSettings()">SETTINGS</button>
                        <button class="btn-system" onclick="game.saveToLocal()">SAVE</button>
                        <button class="btn-system" onclick="game.loadFromLocal()">LOAD</button>
                        <button class="btn-system" onclick="game.resetRound()">RESET</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="side-panel">
            <h3>RULES</h3>
            <div class="tut-item"><span class="tut-label">WIN CONDITION</span><div class="tut-desc">Score 3 points.</div></div>
            <div class="tut-item"><span class="tut-label">TIE-BREAKER</span><div class="tut-desc">If board full:<br>1. Score<br>2. Bunkers</div></div>
            <h3>ORDNANCE</h3>
            <div class="tut-item"><span class="tut-label">ACQUIRING NUKES</span><div class="tut-desc">Score 1st point = +1 Nuke.<br>Score 2nd point = Enemy +1 Nuke.</div></div>
            <div class="tut-item"><span class="tut-label">STANDARD NUKE</span><div class="tut-desc">Radius 1 (Cross).<br>Target: YOUR UNITS ONLY.<br>Blocked by Bunkers.</div></div>
            <div class="tut-item"><span class="tut-label">BOOSTED NUKE</span><div class="tut-desc">Radius 2 (Diamond).<br>Target: ANYWHERE.<br>Destroys Bunkers.</div></div>
        </div>
    </div>
</div>

<div class="overlay" id="overlay">
    <div class="modal">
        <h2 id="winner-title">VICTORY</h2>
        <div class="modal-btn-group">
            <button class="btn-system" onclick="game.resetRound()">RESTART SIMULATION</button>
            <button class="btn-view-board" onclick="game.hideOverlay()">VIEW BOARD STATE</button>
        </div>
    </div>
</div>

<div class="overlay" id="settings-overlay">
    <div class="modal">
        <h2>SYSTEM SETTINGS</h2>
        <div class="setting-row">
            <span class="setting-label">MAP SIZE</span>
            <div class="btn-group">
                <button onclick="game.setMapSize(13)">13x13</button>
                <button onclick="game.setMapSize(15)">15x15</button>
                <button onclick="game.setMapSize(19)">19x19</button>
            </div>
        </div>
        <div class="setting-row">
            <span class="setting-label">UI SCALE</span>
            <input type="range" min="0.7" max="1.3" step="0.1" value="1" oninput="game.setScale(this.value)">
        </div>
        <button class="btn-system" onclick="document.getElementById('settings-overlay').classList.remove('visible')">CLOSE</button>
    </div>
</div>
<div id="toast" class="toast"></div>

<script>
/**
 * CONNECT 5: WAR ROOM v7.2 [VISUAL_POLISH]
 * - Fixed stretched pattern boxes in tutorial.
 * - Added random Room ID generation.
 * - Expanded red highlight to occupied cells during bonus turns.
 */

class SoundSystem {
    constructor() { this.ctx = null; }
    init() { if (!this.ctx) { const AC = window.AudioContext || window.webkitAudioContext; this.ctx = new AC(); } if (this.ctx.state === 'suspended') this.ctx.resume(); }
    playTone(f, t, d, v=0.1) {
        if (!this.ctx) return;
        const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
        o.type = t; o.frequency.setValueAtTime(f, this.ctx.currentTime);
        g.gain.setValueAtTime(v, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + d);
        o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime + d);
    }
    playNoise(d, v=0.2) {
        if (!this.ctx) return;
        const b = this.ctx.createBuffer(1, this.ctx.sampleRate * d, this.ctx.sampleRate);
        const data = b.getChannelData(0); for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
        const s = this.ctx.createBufferSource(); s.buffer = b;
        const g = this.ctx.createGain(); g.gain.setValueAtTime(v, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + d);
        s.connect(g); g.connect(this.ctx.destination); s.start();
    }
    playPlaceP1() { this.playTone(600, 'sine', 0.1); } 
    playPlaceP2() { this.playTone(400, 'sine', 0.12); } 
    playBonus() { this.playTone(800, 'square', 0.1); setTimeout(() => this.playTone(1200, 'square', 0.2), 100); }
    playScore() { this.playTone(400, 'sawtooth', 0.1); setTimeout(() => this.playTone(600, 'sawtooth', 0.1), 100); setTimeout(() => this.playTone(900, 'sawtooth', 0.4), 200); }
    playNuke() { this.playNoise(0.5); }
    playBunker() { this.playTone(150, 'square', 0.4, 0.2); }
    playError() { this.playTone(150, 'sawtooth', 0.2); }
}

const STATE = { EMPTY: 0, P1: 1, P2: 2, P1_SCORED: 3, P2_SCORED: 4, P1_BUNKER: 5, P2_BUNKER: 6, P1_BUNKER_SCORED: 7, P2_BUNKER_SCORED: 8, CRATER: 9 };

// --- MULTIPLAYER CLIENT ---

let socket = null;
let multiplayerEnabled = false;
let clientId = Math.random().toString(36).substr(2, 9);
let currentRoom = "WAR-ROOM-" + Math.floor(1000 + Math.random() * 9000); // Random Room ID
let retryCount = 0;
const MAX_RETRIES = 3;

function initMultiplayer(gameInstance) {
    // Set initial room ID in UI
    document.getElementById('room-input').value = currentRoom;

    const connect = () => {
        if (retryCount >= MAX_RETRIES) {
            updateConnStatus("OFFLINE (LOCAL)", "disconnected");
            gameInstance.showToast("MULTIPLAYER UNAVAILABLE. PLAYING LOCALLY.");
            return;
        }

        try {
            socket = new WebSocket("wss://ticktack-nuke-server.onrender.com");

            socket.onopen = () => {
                console.log("Connected");
                retryCount = 0;
                multiplayerEnabled = true;
                updateConnStatus("CONNECTED", "connected");
                // Heartbeat
                setInterval(() => {
                    if(socket.readyState === 1) socket.send(JSON.stringify({type:"ping"}));
                }, 30000);
            };

            socket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.room !== currentRoom) return;

                    if (data.type === "state") {
                        if (data.sender !== clientId) {
                            gameInstance.setState(data.state);
                        }
                    } else if (data.type === "chat") {
                        gameInstance.addChatMessage(data.msg, data.role);
                    }
                } catch(e) { console.error("Bad message", e); }
            };

            socket.onclose = () => {
                console.log("Disconnected");
                multiplayerEnabled = false;
                if (retryCount < MAX_RETRIES) {
                    updateConnStatus(`RECONNECTING (${retryCount+1}/${MAX_RETRIES})...`, "connecting");
                    retryCount++;
                    setTimeout(connect, 3000);
                } else {
                    updateConnStatus("OFFLINE (LOCAL)", "disconnected");
                }
            };

            socket.onerror = (e) => {
                socket.close();
            };

        } catch (e) {
            updateConnStatus("OFFLINE (LOCAL)", "disconnected");
        }
    };
    connect();
}

function updateConnStatus(text, cls) {
    const dot = document.getElementById('conn-dot');
    const txt = document.getElementById('conn-text');
    if(dot && txt) {
        dot.className = `status-dot ${cls}`;
        txt.textContent = text;
    }
}

class Connect5 {
    constructor() {
        this.mapSize = 15;
        this.winningScore = 3;
        this.sound = new SoundSystem();
        
        this.grid = [];
        this.currentPlayer = 1;
        this.scores = { 1: 0, 2: 0 };
        this.nukes = { 1: 0, 2: 0 };
        this.boosters = { 1: 0, 2: 0 };
        this.bunkers = { 1: 0, 2: 0 };
        this.bonusTurn = false;
        this.ignoreIsolation = false;
        this.lastMove = null;
        this.gameActive = true;
        this.uiTargetingMode = false;
        this.uiBoostActive = false;

        this.boardElement = document.getElementById('board');
        this.appRoot = document.getElementById('app-root');
        this.statusText = document.getElementById('status-text');
        this.isoIndicator = document.getElementById('iso-indicator');
        this.toast = document.getElementById('toast');
        this.chatLog = document.getElementById('chat-log');
        this.chatInput = document.getElementById('chat-input');

        this.chatInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") this.sendChatFromInput();
        });

        this.init();
    }

    init() {
        if (!this.loadFromLocal()) this.createBoard(this.mapSize);
        this.updateUI();
        this.checkIsolationAvailability();
        document.body.addEventListener('mousedown', () => this.sound.init(), {once:true});
    }

    joinRoom(roomName) {
        currentRoom = roomName || "WAR-ROOM-1";
        this.logSystemMessage(`JOINED FREQUENCY: ${currentRoom}`);
        // Reset game on room change to prevent state conflict? Optional.
    }

    sendState() {
        if (multiplayerEnabled && socket?.readyState === 1) {
            socket.send(JSON.stringify({
                type: "state",
                room: currentRoom,
                sender: clientId,
                state: this.getState()
            }));
        }
    }

    sendChatFromInput() {
        const text = this.chatInput.value.trim();
        if (!text) return;
        
        const role = this.currentPlayer === 1 ? "p1" : "p2"; 
        this.addChatMessage(text, role);
        this.chatInput.value = "";

        if (multiplayerEnabled && socket?.readyState === 1) {
            socket.send(JSON.stringify({
                type: "chat",
                room: currentRoom,
                msg: text,
                role: role
            }));
        }
    }

    addChatMessage(text, role) {
        const div = document.createElement("div");
        div.className = `chat-msg ${role || 'system'}`;
        const prefix = role === "p1" ? "COM-A: " : (role === "p2" ? "COM-B: " : "> ");
        div.textContent = prefix + text;
        this.chatLog.appendChild(div);
        this.chatLog.scrollTop = this.chatLog.scrollHeight;
    }

    logSystemMessage(text) {
        this.addChatMessage(text, "system");
    }

    getState() {
        return {
            grid: JSON.parse(JSON.stringify(this.grid)),
            currentPlayer: this.currentPlayer,
            scores: { ...this.scores },
            nukes: { ...this.nukes },
            boosters: { ...this.boosters },
            bunkers: { ...this.bunkers },
            bonusTurn: this.bonusTurn,
            ignoreIsolation: this.ignoreIsolation,
            lastMove: this.lastMove ? { ...this.lastMove } : null,
            gameActive: this.gameActive,
            mapSize: this.mapSize
        };
    }

    setState(state) {
        this.detectStateChange(state);
        this.grid = state.grid;
        this.currentPlayer = state.currentPlayer;
        this.scores = state.scores;
        this.nukes = state.nukes;
        this.boosters = state.boosters;
        this.bunkers = state.bunkers;
        this.bonusTurn = state.bonusTurn;
        this.ignoreIsolation = state.ignoreIsolation;
        this.lastMove = state.lastMove;
        this.gameActive = state.gameActive;
        this.mapSize = state.mapSize;

        this.renderBoard();
        this.updateUI();
        if (!this.gameActive) this.showEndScreen();
    }

    detectStateChange(newState) {
        if (newState.scores[1] > this.scores[1] || newState.scores[2] > this.scores[2]) {
            this.sound.playScore();
            this.logSystemMessage(`SCORE DETECTED: ${newState.scores[1]} - ${newState.scores[2]}`);
            return; 
        }
        if (newState.lastMove && (!this.lastMove || newState.lastMove.r !== this.lastMove.r || newState.lastMove.c !== this.lastMove.c)) {
             const movedCell = newState.grid[newState.lastMove.r][newState.lastMove.c];
             const owner = this.getPlayerId(movedCell);
             if (owner === 1) this.sound.playPlaceP1();
             else if (owner === 2) this.sound.playPlaceP2();
        }
    }

    applyMove(move) {
        if (!this.gameActive) return;

        if (move.type === 'place') {
            this.internalExecutePlace(move.r, move.c);
        } else if (move.type === 'nuke') {
            this.internalExecuteNuke(move.r, move.c, move.boosted);
        }

        this.updateUI();
        this.sendState(); 
    }

    handleCellClick(r, c) {
        if (this.uiTargetingMode) {
            this.applyMove({ type: 'nuke', r, c, boosted: this.uiBoostActive });
        } else {
            this.applyMove({ type: 'place', r, c });
        }
    }

    uiToggleNuke() {
        if (this.nukes[this.currentPlayer] <= 0) { this.showToast("SILOS EMPTY"); this.sound.playError(); return; }
        this.uiTargetingMode = !this.uiTargetingMode;
        if (!this.uiTargetingMode) this.uiBoostActive = false;
        this.updateUI();
    }

    uiToggleBoost() {
        if (this.boosters[this.currentPlayer] <= 0) { this.showToast("NO BOOSTERS"); this.sound.playError(); return; }
        if (this.nukes[this.currentPlayer] <= 0) { this.showToast("NEED NUKE TO BOOST"); this.sound.playError(); return; }
        this.uiBoostActive = !this.uiBoostActive;
        if (!this.uiTargetingMode) this.uiTargetingMode = true; 
        this.updateUI();
    }

    internalExecutePlace(r, c) {
        if (this.grid[r][c] !== STATE.EMPTY) { this.sound.playError(); return; }
        if (this.bonusTurn && !this.ignoreIsolation && !this.isIsolated(r, c)) {
            this.showToast("BONUS PIECE MUST BE ISOLATED");
            this.sound.playError();
            return;
        }

        const prevMove = this.lastMove;
        this.grid[r][c] = this.currentPlayer === 1 ? STATE.P1 : STATE.P2;
        this.lastMove = { r, c };
        
        if (this.currentPlayer === 1) this.sound.playPlaceP1();
        else this.sound.playPlaceP2();
        
        this.updateCellVisual(r, c);
        if (prevMove) this.updateCellVisual(prevMove.r, prevMove.c);

        this.resolvePostMove(r, c);
    }

    internalExecuteNuke(r, c, boosted) {
        if (this.nukes[this.currentPlayer] < 1) return;
        if (boosted && this.boosters[this.currentPlayer] < 1) return;
        
        if (!boosted) {
            if (this.getPlayerId(this.grid[r][c]) !== this.currentPlayer) {
                this.showToast("INVALID TARGET: ALLIED UNIT REQUIRED");
                this.sound.playError();
                return;
            }
        }

        const affected = [];
        const radius = boosted ? 2 : 1;
        for (let dr = -radius; dr <= radius; dr++) {
            for (let dc = -radius; dc <= radius; dc++) {
                if (Math.abs(dr) + Math.abs(dc) <= radius && this.isValid(r+dr, c+dc)) {
                    affected.push({ r: r+dr, c: c+dc });
                }
            }
        }

        this.sound.playNuke();
        this.logSystemMessage(boosted ? "BOOSTED NUKE LAUNCHED" : "NUKE LAUNCHED");
        document.querySelector('.board-container').classList.add('impact');
        
        affected.forEach(pos => {
            const s = this.grid[pos.r][pos.c];
            const isBunker = (s >= 5 && s <= 8);
            if (!isBunker || boosted) {
                const owner = this.getPlayerId(s);
                if (isBunker && owner > 0) this.bunkers[owner]--;
                this.grid[pos.r][pos.c] = STATE.CRATER;
            }
        });

        this.nukes[this.currentPlayer]--;
        if (boosted) this.boosters[this.currentPlayer]--;
        
        this.uiTargetingMode = false;
        this.uiBoostActive = false;
        this.bonusTurn = false;
        
        setTimeout(() => {
            document.querySelector('.board-container').classList.remove('impact');
            this.renderBoard();
            this.switchTurn();
        }, 350);
    }

    resolvePostMove(r, c) {
        const player = this.currentPlayer;
        const scored = this.checkScoring(r, c);
        
        if (this.checkBoardFull()) { this.endRound("FULL"); return; }
        if (scored) {
            this.bonusTurn = false;
            this.ignoreIsolation = false;
            this.sound.playScore();
            if (this.scores[player] >= this.winningScore) { this.endRound("SCORE"); return; }
            this.switchTurn();
            return;
        }

        let triggers = [];
        let earnedBonus = false;

        const plus = this.checkForPlus(r, c);
        if (plus) {
            this.boosters[player]++;
            this.sound.playBunker();
            plus.forEach(pos => {
                const s = this.grid[pos.r][pos.c];
                const wasBunker = (s >= 5 && s <= 8);
                if (!wasBunker) this.bunkers[player]++;
                const scored = (s === 3 || s === 4 || s === 7 || s === 8);
                this.grid[pos.r][pos.c] = player === 1 ? (scored ? 7 : 5) : (scored ? 8 : 6);
                this.updateCellVisual(pos.r, pos.c);
                const cell = this.getCell(pos.r, pos.c);
                const piece = cell.querySelector('.piece');
                if (piece) piece.classList.add('forming');
            });
            triggers.push("BUNKERS ESTABLISHED");
        }

        if (!this.bonusTurn) {
            const square = this.checkForSquare(r, c);
            if (square) {
                earnedBonus = true;
                this.sound.playBonus();
                square.forEach(pos => this.getCell(pos.r, pos.c).querySelector('.piece')?.classList.add('square-flash'));
                triggers.push("BONUS TURN");
            }
        }

        if (triggers.length) this.showToast(triggers.join(" + "));

        if (earnedBonus) {
            this.bonusTurn = true;
            this.checkIsolationAvailability(); 
            this.refreshGridVisuals(); 
            return;
        } 
        
        if (this.bonusTurn) {
            this.bonusTurn = false;
            this.ignoreIsolation = false;
            this.refreshGridVisuals();
            this.switchTurn();
        } else {
            this.switchTurn();
        }
    }

    switchTurn() {
        this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
        this.uiTargetingMode = false;
        this.uiBoostActive = false;
        this.checkIsolationAvailability();
        this.refreshGridVisuals();
        this.updateUI();
    }

    getPlayerId(s) {
        if ([1,3,5,7].includes(s)) return 1;
        if ([2,4,6,8].includes(s)) return 2;
        return 0;
    }
    
    isActivePiece(s) { return (s === 1 || s === 2 || s === 5 || s === 6); }

    isValid(r, c) { return r >= 0 && r < this.mapSize && c >= 0 && c < this.mapSize; }

    isIsolated(r, c) {
        for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                if (this.isValid(r+dr, c+dc)) {
                    const s = this.grid[r+dr][c+dc];
                    if (s !== STATE.EMPTY && s !== STATE.CRATER) return false;
                }
            }
        }
        return true;
    }

    checkIsolationAvailability() {
        if (!this.bonusTurn) return;
        let possible = false;
        for (let r=0; r<this.mapSize; r++) {
            for (let c=0; c<this.mapSize; c++) {
                if (this.grid[r][c] === STATE.EMPTY && this.isIsolated(r, c)) { possible = true; break; }
            }
            if (possible) break;
        }
        this.ignoreIsolation = !possible;
    }

    checkForSquare(r, c) {
        const p = this.currentPlayer;
        const offsets = [[-1,-1], [-1,0], [0,-1], [0,0]];
        for (let [dr, dc] of offsets) {
            let match = true;
            let coords = [];
            for (let i=0; i<2; i++) {
                for (let j=0; j<2; j++) {
                    const nr = r+dr+i, nc = c+dc+j;
                    if (!this.isValid(nr, nc)) { match = false; break; }
                    const s = this.grid[nr][nc];
                    if (this.getPlayerId(s) !== p || !this.isActivePiece(s)) { match = false; break; }
                    coords.push({r:nr, c:nc});
                }
                if (!match) break;
            }
            if (match) return coords;
        }
        return null;
    }

    checkForPlus(r, c) {
        const p = this.currentPlayer;
        const potential = [[0,0], [0,1], [0,-1], [1,0], [-1,0]];
        for (let [dr, dc] of potential) {
            const cr = r+dr, cc = c+dc;
            if (!this.isValid(cr, cc)) continue;
            const cs = this.grid[cr][cc];
            if ([5,6,7,8].includes(cs)) continue; 
            if (this.getPlayerId(cs) !== p || !this.isActivePiece(cs)) continue;
            const arms = [[0,1], [0,-1], [1,0], [-1,0]];
            if (arms.every(([ar, ac]) => {
                const tr = cr+ar, tc = cc+ac;
                if (!this.isValid(tr, tc)) return false;
                const ts = this.grid[tr][tc];
                return this.getPlayerId(ts) === p && this.isActivePiece(ts);
            })) {
                return [[0,0], ...arms].map(([ar, ac]) => ({ r: cr+ar, c: cc+ac }));
            }
        }
        return null;
    }

    checkScoring(r, c) {
        const p = this.currentPlayer;
        const directions = [[0,1], [1,0], [1,1], [1,-1]];
        let found = false;
        directions.forEach(([dr, dc]) => {
            let line = [];
            for (let i=-4; i<=4; i++) {
                const nr = r+dr*i, nc = c+dc*i;
                if (this.isValid(nr, nc)) line.push({ r: nr, c: nc, s: this.grid[nr][nc] });
            }
            for (let i=0; i <= line.length - 5; i++) {
                const seg = line.slice(i, i+5);
                if (seg.every(cell => this.getPlayerId(cell.s) === p && ![3,4,7,8].includes(cell.s))) {
                    this.applyScoreSegment(seg);
                    found = true;
                    break; 
                }
            }
        });
        return found;
    }

    applyScoreSegment(seg) {
        this.scores[this.currentPlayer]++;
        if (this.scores[this.currentPlayer] === 1) this.nukes[this.currentPlayer]++;
        else if (this.scores[this.currentPlayer] === 2) this.nukes[this.currentPlayer === 1 ? 2 : 1]++;
        
        seg.forEach(cell => {
            const s = this.grid[cell.r][cell.c];
            if (s === 1) this.grid[cell.r][cell.c] = 3;
            else if (s === 2) this.grid[cell.r][cell.c] = 4;
            else if (s === 5) this.grid[cell.r][cell.c] = 7;
            else if (s === 6) this.grid[cell.r][cell.c] = 8;
            this.updateCellVisual(cell.r, cell.c);
        });
    }

    checkBoardFull() { return this.grid.every(row => row.every(c => c !== STATE.EMPTY)); }

    createBoard(size) {
        this.mapSize = size;
        this.grid = Array(size).fill().map(() => Array(size).fill(0));
        this.renderBoard();
    }

    renderBoard() {
        if (!this.boardElement) return;
        this.boardElement.innerHTML = '';
        this.boardElement.style.gridTemplateColumns = `repeat(${this.mapSize}, 1fr)`;
        for (let r=0; r<this.mapSize; r++) {
            for (let c=0; c<this.mapSize; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.onclick = () => this.handleCellClick(r, c);
                this.boardElement.appendChild(cell);
                this.updateCellVisual(r, c);
            }
        }
    }

    refreshGridVisuals() {
        for(let r=0; r<this.mapSize; r++) {
            for(let c=0; c<this.mapSize; c++) {
                this.updateCellVisual(r, c);
            }
        }
    }

    updateCellVisual(r, c, animateBunker = false) {
        const cell = this.getCell(r, c);
        if (!cell) return;
        const s = this.grid[r][c];
        cell.className = 'cell';
        cell.innerHTML = '';
        if (s === STATE.CRATER) { cell.classList.add('crater'); return; }
        if (s === STATE.EMPTY) {
            if (this.bonusTurn && !this.ignoreIsolation) {
                // If cell is empty but NOT isolated, it's invalid for bonus
                if (!this.isIsolated(r, c)) cell.classList.add('invalid-isolation');
            }
            if (this.uiTargetingMode && !this.uiBoostActive) cell.classList.add('invalid-target');
            return;
        }

        const p = document.createElement('div');
        p.className = 'piece';
        const owner = this.getPlayerId(s);
        p.classList.add(owner === 1 ? 'p1' : 'p2');
        if ([3,4,7,8].includes(s)) p.classList.add('scored');
        if ([5,6,7,8].includes(s)) p.classList.add('bunker');
        if (this.lastMove?.r === r && this.lastMove?.c === c) p.classList.add('last-move');
        cell.appendChild(p);
        
        // Also highlight occupied cells during restricted bonus turn
        if (this.bonusTurn && !this.ignoreIsolation) {
             cell.classList.add('invalid-isolation');
        }

        if (this.uiTargetingMode && !this.uiBoostActive && owner !== this.currentPlayer) {
            cell.classList.add('invalid-target');
        }
    }

    getCell(r, c) { return this.boardElement?.children[r * this.mapSize + c]; }

    updateUI() {
        const p = this.currentPlayer;
        document.getElementById('p1-panel').classList.toggle('active-turn', p === 1);
        document.getElementById('p2-panel').classList.toggle('active-turn', p === 2);
        document.getElementById('score1').textContent = this.scores[1];
        document.getElementById('score2').textContent = this.scores[2];
        document.getElementById('nuke1').textContent = this.nukes[1];
        document.getElementById('nuke2').textContent = this.nukes[2];
        document.getElementById('boost1').textContent = this.boosters[1];
        document.getElementById('boost2').textContent = this.boosters[2];
        document.getElementById('bunker1').textContent = this.bunkers[1];
        document.getElementById('bunker2').textContent = this.bunkers[2];

        let txt = p === 1 ? "COMMANDER A // AWAITING INPUT" : "COMMANDER B // AWAITING INPUT";
        let statusClass = "status-text";
        if (this.bonusTurn) { txt = "BONUS TURN ACTIVE"; statusClass = "status-bonus"; }
        else if (this.uiTargetingMode) { txt = this.uiBoostActive ? "TARGETING BOOSTED ICBM..." : "TARGETING STANDARD ICBM..."; statusClass = "status-bonus"; }
        
        this.statusText.textContent = txt;
        this.statusText.className = statusClass;
        
        this.statusText.style.color = (this.bonusTurn || this.uiTargetingMode) ? "var(--text-boost)" : (p === 1 ? "var(--text-main)" : "var(--text-sec)");

        const iso = this.isoIndicator;
        if (this.bonusTurn) {
            iso.textContent = this.ignoreIsolation ? "ISOLATION: IMPOSSIBLE; PLACE FREELY" : "ISOLATION: REQUIRED";
            iso.style.color = "var(--text-boost)";
            iso.classList.toggle('available', this.bonusTurn && !this.ignoreIsolation);
        } else {
            iso.textContent = "";
        }

        const bn = document.getElementById('btn-nuke');
        bn.disabled = this.nukes[p] <= 0;
        bn.innerText = this.uiTargetingMode ? "CANCEL" : "LAUNCH ICBM";
        bn.classList.toggle('active', this.uiTargetingMode);

        const bb = document.getElementById('btn-boost');
        bb.disabled = this.boosters[p] <= 0;
        bb.classList.toggle('active', this.uiBoostActive);

        if (this.boardElement) {
            this.boardElement.className = 'board';
            if (this.uiTargetingMode) this.boardElement.classList.add(this.uiBoostActive ? 'targeting-boosted' : 'targeting');
        }
    }

    showToast(m) {
        const t = this.toast;
        t.textContent = m; t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 2000);
    }

    endRound(reason) {
        this.gameActive = false;
        this.showEndScreen(reason);
    }

    showEndScreen(reason) {
        const h2 = document.getElementById('winner-title');
        let win = "DRAW";
        if (this.scores[1] > this.scores[2]) win = "COMMANDER A";
        else if (this.scores[2] > this.scores[1]) win = "COMMANDER B";
        else if (this.bunkers[1] > this.bunkers[2]) win = "COMMANDER A (BUNKERS)";
        else if (this.bunkers[2] > this.bunkers[1]) win = "COMMANDER B (BUNKERS)";
        h2.textContent = win === "DRAW" ? "STALEMATE" : `${win} VICTORIOUS`;
        document.getElementById('overlay').classList.add('visible');
    }

    resetRound() {
        this.scores = {1:0, 2:0}; this.nukes = {1:0, 2:0}; this.boosters = {1:0, 2:0}; this.bunkers = {1:0, 2:0};
        this.currentPlayer = 1; this.bonusTurn = false; this.lastMove = null; this.gameActive = true;
        this.uiTargetingMode = false; this.uiBoostActive = false;
        this.createBoard(this.mapSize);
        this.updateUI();
        document.getElementById('overlay').classList.remove('visible');
        this.logSystemMessage("WAR GAMES RESET");
    }

    setMapSize(s) { this.mapSize = s; this.resetRound(); document.getElementById('settings-overlay').classList.remove('visible'); }
    setScale(v) { document.getElementById('app-root').style.transform = `scale(${v})`; }
    openSettings() { document.getElementById('settings-overlay').classList.add('visible'); }
    hideOverlay() { document.getElementById('overlay').classList.remove('visible'); }

    saveToLocal() { localStorage.setItem('con5_v6_save', JSON.stringify(this.getState())); this.showToast("LOCAL STATE SAVED"); }
    loadFromLocal() { const s = localStorage.getItem('con5_v6_save'); if (s) { this.setState(JSON.parse(s)); this.showToast("LOCAL STATE LOADED"); return true; } return false; }
}

const game = new Connect5();
initMultiplayer(game);
</script>
</body>
</html>
